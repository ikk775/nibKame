\documentclass[a4paper,titlepage,report]{jsbook}

\usepackage[dvipdfmx]{graphicx}
\usepackage{emp} % 図の描画用
\usepackage[sc,slantedGreek]{mathpazo}
\usepackage{listings}
\usepackage{jlisting}
\usepackage{mathtools} % Ams-TeXの使用
\usepackage{mathrsfs} % 数式フォント
\usepackage{amssymb,amsthm} % 記号と定理環境
\usepackage{proof} % 証明図
\usepackage{url} % URL
\usepackage{longtable} % 複数ページに亙る長い表
\usepackage{yhmath} % 長い括弧など
\usepackage{tablists}

\input{preamble}

\begin{document}
\title{電子情報工学科実験報告書 \\ 関数型言語の設計と実装}
\author{
\begin{tabular}{llr}
 L班 & 07317 & 小堀 育男 \\
     & 07322 & 酒本 典明
\end{tabular}
}
\date{平成23年2月3日}

\frontmatter

\maketitle

\tableofcontents
\listoffigures
\listoftables
\lstlistoflistings

\newpage

\mainmatter % 序論も本文の内

\chapter{序論}\label{ch:intro}
\begin{abstract}
 本実験課題選定の理由と目的について論じる．また，実装の概要と報告書の構成を述べる．
\end{abstract}

\section{目的}
関数型言語の有用性はHughes\cite{hughes1989functional}などにより主張され
ていた．現在では，関数型言語に由来する機能が，C++やJava, C\# など
の言語に取り込まれている．またScala\footnote{\url{http://www.scala-lang.org/}}
やF\#{}\footnote{\url{http://msdn.microsoft.com/ja-jp/fsharp}}
など既存の手続き型言語との連携を強く意識した言語も登場している．

関数型言語に特徴的な機能として第一級の関数やクロージャなどがある．これら
は計算機の命令セットの持つ機能からかけ離れている．こういった機能を持った
言語を設計し，実装することで機能に対する理解を深めることを目標とする．

そのために，我々は静的に強く型付けされる関数型言語nibkameを設計しコンパ
イラを実装した．これは学生実験における参照実装として開発された
MinCaml\cite{住井英二郎:2008-04-24}を基にして開発を行なった．

MinCamlおよびMinCamlコンパイラは簡潔な実装(約2000行ほど)で性能の良いコー
ドを生成することに特徴のある関数型言語である．構文はObjective
Caml\footnote{\url{http://caml.inria.fr/ocaml/}}のサブセットであり,算術演算や
タプル構造，破壊的代入の可能な配列，高階関数，再帰と末尾呼び出し，型推論
などの機能が実現されており，レイトレーシングなどの複雑なプログラムを記述
することができる．MinCamlはプログラム言語処理系の教材として用いられるこ
とを主眼としており，その機能選定は実装を簡潔に保つことを重視して行われた．

簡潔さを保つために，多くのアプリケーションプログラムを記述するときに必須
でない機能は省略された．その中にはMinCamlコンパイラの記述に多く用いられ
ている代数的データ型やパターンマッチングなどが存在する．
nibkameではそういった機能と，その他にも生産性に高い影響を与える機能を追
加することでより実用的な言語を開発することを目指した．
MinCamlコンパイラはターゲットとする計算機としてSPARCとPowerPCをサポート
している．しかし実行する計算機の確保の容易さから，nibkameコンパイラはター
ゲットをx86プロセッサとした．

\section{実装概要}
コンパイラの主要部分はObjective
Camlを用いて実装した．構文解析部分はScheme
(処理系としては
Gauche\footnote{\url{http://practical-scheme.net/gauche/index-j.html}})
を用いた．実行時ランタイムはC言語にて実装した．
% ここに行数などを含むといいみたい

2011年1月12日時点でのソースコードの全行数は7001行であり，
ソースソードの目的別言語別行数内訳は\refTbl{tbl:sourcecode-lines}のようになっている．

\begin{table}[hbt]
    \caption{ソースコードの行数}\label{tbl:sourcecode-lines}
    \begin{center}
    \begin{tabular}{cllr@{行}}
        \Hline
        \multicolumn{1}{c}{目的} & \multicolumn{2}{c}{言語} & \multicolumn{1}{c}{行数} \\
        \hline
        本体        & O'Caml & 実装             & 4820 \\
	                & O'Caml & インターフェース & 781 \\
	                & Scheme &                  & 337 \\
	                & C言語  &                  & 0 \\
        単体テスト  & O'Caml & 実装             & 1063 \\
        \Hline
    \end{tabular}
    \end{center}
\end{table}

\section{報告書の構成} % ここは内容にあわせて書き換えてください．あと
			  % subsectionはオーバースペックな気が．
\refCh{ch:preparation}ではコンパイラの動作を理解するために必要となる理論
や規則について概説する．本報告書で用いる論理学や集合の記法についても説明
する．
\refCh{ch:lang_design}では，nibkame言語に搭載された機能のうち関数型言語
に特有なものについて説明し，最終的に実装された言語機能と構文を示す．
\refCh{ch:impl}ではコンパイラのモジュール構造と各フェーズの対応を示し，
コンパイラの実装について説明する．
\refCh{ch:sample-program}では実際のnibkameプログラムの例を示し，コンパイラの動作
と得られる目的プログラムについて説明する．
\refCh{ch:conclude}では実装した機能についてまとめ，これからの課題を議論する．

%\mainmatter
%\chapter{原理}\label{ch:原理}

\chapter{準備}\label{ch:preparation}
\begin{abstract}
本報告書で用いる理論・記法について概説する． 
本章は直感的な解りやすさを最優先したため，
論理的に不正確な箇所が多々あるがお赦し願いたい．
\end{abstract}

\section{全体的な記法について}\label{sc:about-notation}
以下，演算子の結合力を表す際に，
\begin{equation}\label{eq:bonding-strength}
\times \gtrdotrel +
\end{equation}
と表すこととする．
これは，$A\times B + C$という式があったときに$(A\times B)+ C$と解釈することを意味する．

等号系の記号の使い分けは\refTbl{tbl:equal-usage}のようにする．

\begin{table}[hbt]
    \caption{等号系記号の使い分け}\label{tbl:equal-usage}
    \begin{center}
    \begin{tabular}{cp{40zw}}
        \Hline
        \multicolumn{1}{c}{記号} & \multicolumn{1}{c}{目的} \\
        \hline
        $=$ & 通常の等値，即ち数値・真偽値・集合などの等しさを真偽値で表す，または，等しいことを言明する． \\
        $\equiv$ & $=$よりも広い意味で同じであることを表す． \\
        $\defeq$ & 通常の式において左辺の記号が右辺で定義されることを示す．\\
        $\Coloneqq$ & BNFにおいて，左辺の記号が右辺で定義されることを示す．\refSc{sc:about-BNF-form} \\
        \Hline
    \end{tabular}
    \end{center}
\end{table}

変数$e$の動く領域を$\varrange{e}$と表すこととする\footnote{一般的な方法ではない}．

\begin{resbonsiblesection}{集合について}{\sakamoto}\label{sc:about-set}
元として含むことを表す記号として$\in$，$\ni$を用いる.

部分集合を表す記号として$\msubset$，$\msupset$を，
真部分集合を表す記号として$\mpsubset$，$\mpsupset$を用いる． 

空集合の記号としては$\emptyset$を用いる.

集合$x$の羃集合は$\powerset x$若しくは$\powerset(x)$と書く
\footnote{$2^x$や$\boldsymbol{2}^x$という表記も一般的．}．

順序対若しくは単純に対は，$(x,y)$と表すことにする\footnote{標準的には$\left<x,y\right>$である．}．
順序対は
\begin{equation}
(x_0,x_1) = (y_0,y_1) \iff x_0 = y_0 \land x_1 = y_1
\end{equation}
という式によって特徴付けられる．

組は$(x_0,x_1,\cdots,x_n)$と表すことにする\footnote{これも標準的には$\left<x_0,x_1,\cdots,x_n\right>$である．}．
順序対と同様に
\begin{equation}
(x_0,x_1,\cdots,x_n) = (y_0,y_1,\cdots,x_n) \iff \foralldot{i\in\{0,1,\cdots,n\}}{x_i = y_i}
\end{equation}
となる．

標準射影とは，組または対からその構成要素を取り出す演算であり，
順序対の集合\jpdash 例えば，$\{(x,y)|x\in\R,y\in\Z\}$などにおいて，
\end{resbonsiblesection}

\section{論理について}\label{sc:about-logic}
真・偽を表すの記号として夫々，$\ltrue$，$\lfalse$を用いる.
論理和・論理積・否定・含意の記号として夫々，$\lor$，$\land$，$\lnot$，$\limpl$を用いる.
変数$x$がその領域$\varrange{x}$を動くとき，
述語$P(x)$が全ての$x$で真になることを$\foralldot{x}{P(x)}$，
述語$P(x)$がある$x$で真になることを$\existsdot{x}{P(x)}$と表す．
$\foralldot{x}{\foralldot{y}{\cdots}}$は$\foralldot{x,y,\cdots}{}$と略記する．
$\exists$も同様．

$\forall$，$\exists$，$\lnot$，$\limpl$は右結合性，
例えば，$\lnot\lnot A\equiv \lnot(\lnot A)$，$A\limpl B\limpl C \equiv A\limpl (B\limpl C)$とする．
夫々の演算子の優先順位は$\lnot\gtrdotrel\land,\lor\gtrdotrel\limpl$となる．

\begin{equation}\label{eq:def-mp}
\infer[\rulename{M.P.}]{\beta}{\alpha & \alpha \limpl \beta}
\end{equation}
は，$\alpha$と$\alpha \limpl \beta$という仮定から，\rulename{M.P.}という推論規則によって$\beta$が導き出されることを表す記法である.
\ref{eq:def-mp}によって定義される推論規則は，推論規則内の$\alpha$，$\beta$に式を代入することによって
\begin{equation}\label{eq:def-mp-instance-1}
\infer[\rulename{M.P.}]{A\land B}{A & A \limpl A\land B}
\end{equation}
や，
\begin{equation}\label{eq:def-mp-instance-2}
\infer[\rulename{M.P.}]{\foralldot{x}{Q(a, x) \limpl P(x)}}{\existsdot{x}{P(x)} & \existsdot{x}{P(x)} \limpl \foralldot{x}{Q(a, x) \limpl P(x)}}
\end{equation}
も表す．
この例における$\alpha$，$\beta$のように，超文脈的に扱われる変数のことをメタ変数(meta-variable)と呼ぶ．


$\Gamma_1,\Gamma_2,\cdots\vdash A_1, A_2,\cdots$は，
主に，$\Gamma_1, \Gamma_2, \cdots$から$A_1, A_2, \cdots$が推論できることを表す記法として用いる.

\section{バッカス・ナウア記法について}\label{sc:about-BNF-form}
バッカス・ナウア記法（Backus-Naur Form, BNF）
は文脈自由文法を定義するのに用いられるメタ言語であって，
プログラミング言語の構文記述やデータ構造の記述など，広汎に利用される．
計算機科学でも式として頻繁に用いられるので解説する．

$\Coloneqq$の左辺にある名前は右辺にある式で定義される．
例えば，
\begin{equation}\label{eq:bnf-example-1} 
e\Coloneqq \mathsf{abc}
\end{equation}
というBNFに対しては
\begin{equation}
\varrange{e} = \{\mathsf{abc}\}
\end{equation}
となる．

右辺において$\mid$は「または」の意味を表し，$\mid$で区切られたいずれかの式に当てはまる．例えば，
\begin{equation}\label{eq:bnf-example-2} 
e\Coloneqq \mathsf{a} \mid \mathsf{b} \mid \mathsf{c}
\quad\text{または}\quad
\begin{array}{rcl}
    e    &\Coloneqq& \mathsf{a} \\
            &\mid&   \mathsf{b} \\
            &\mid&   \mathsf{c} 
\end{array}
\quad\text{または}\quad
\begin{array}{rcl}
    e    &\Coloneqq& \mathsf{a} \\
            &\mid&   \mathsf{b} \\
            &\mid&   \mathsf{c} 
\end{array}
\end{equation}
というBNFに対しては
\begin{equation}
\varrange{e} = \{\mathrm{a}, \mathrm{b}, \mathrm{c}\}
\end{equation}
となる．

右辺において左辺の記号が使われた場合は再帰となる
\begin{equation}\label{eq:bnf-example-3} 
\begin{array}{rcl}
    e    &\Coloneqq& \mathsf{a} \\
            &\mid&   e\mathsf{'} 
\end{array}
\end{equation}
というBNFに対しては
\begin{equation}
\varrange{e} = \{\mathrm{a}, \mathrm{a'}, \mathrm{a''}, \mathrm{a'''}, \cdots \}
\end{equation}
となる．

\section{ラムダ式について}\label{sc:about-lambda-expression}
ラムダ式(lambda expression，$\lambda$-expression) とは，一言で言ってしまうと関数そのものを抽象化したものである．

例えば以下の式を考えよう．
\begin{align}
f(x) &= (x + 1)^2\\
f(x + 1) &= {\left((x + 1) + 1\right)}^2 = x^2 + 4x + 4\\
(x + 1) &= x + 1
\end{align}
これは$(x + 1)$に対して関数$f$を適用すると$x^2 + 2x + 1$となるが，
関数を適用しないとそれは$x + 1$そのものであることを表している．

では逆に，$f$に引数を適用しないとどうなるのであろうか．
\begin{align}
f(x) &= x^2 + 2x + 1\\
f    &= \;?
\end{align}
この場合の$f$そのものを表すのにラムダ式を用いることが出来，そうすると
\begin{align}
f &= \lambdadot{x}{(x^2 + 2x + 1)}
\end{align}
となって関数そのものを陽に扱うことが出来る．
以下，必要の無い限り括弧は省略し，$\lambdadot{x}{(x^2 + 2x + 1)}$は$\lambdadot{x}{x^2 + 2x + 1}$と書く．

ラムダ式を用いて記述した関数に引数を適用させると，
\begin{align}
f(y) &= (\lambdadot{x}{x^2 + 2x + 1})(y) = y^2 + 2y + 2 \\
f(2) &= (\lambdadot{x}{x^2 + 2x + 1})(2) = 2^2 + 2\cdot 2 + 1 = 9
\end{align}
となる．

次に複数引数の関数を考えよう．
\begin{align}
g(x, y) &= x + y
\end{align}
この関数を表すためには，
$\lambdadot{x,y}{}$という記法を導入するのが良いと思われる．
従って，
\begin{align}
\label{eq:lambda-multiple}
g &= \lambdadot{x,y}{x + y}\\
\label{eq:lambda-multiple-inst}
g(a, b) &= a + b\\
g(1, 2) &= (\lambdadot{x,y}{x + y})(1, 2) = 1 + 2 = 3
\end{align}
と表せる．

ここで，天下り的ではあるが，$\lambdadot{x}{\lambdadot{y}{x+y}}$を考える．
すると，
\begin{gather}
\begin{aligned}
\label{eq:lambda-curried}
h &= \lambdadot{x}{\lambdadot{y}{x+y}} \\
\end{aligned} \\
\begin{aligned}
\label{eq:lambda-curried-partial}
h(a) &= (\lambdadot{x}{\lambdadot{y}{x+y}})(a)\\
     &= {\lambdadot{y}{a+y}}
\end{aligned} \\
\begin{aligned}
\label{eq:lambda-curried-inst}
\left(h(a)\right)(b) &= \left((\lambdadot{x}{\lambdadot{y}{x+y}})(a)\right)(b) \\
        &= (\lambdadot{y}{a+y})(b)\\
        &= a + b
\end{aligned} \\
\begin{aligned}
\left(h(1)\right)(2) &= \left((\lambdadot{x}{\lambdadot{y}{x+y}})(1)\right)(2) \\
        &= (\lambdadot{y}{1+y})(2) \\
        &= 1 + 2 = 3
\end{aligned}
\end{gather}
このようになる．
以下，$f(a)(b)(c)\cdots$は
$\delimitershortfall-1pt\left({\cdots\left({\left({\left({f(a)}\right)(b)}\right)(c)}\right)\cdots}\right)$
を表すものとし，
必要の無い限り括弧を省略する．

ここで，
\refEq{eq:lambda-multiple-inst}と\refEq{eq:lambda-curried-inst}
を見比べると$g(a, b) = h(a)(b)$であることがわかる．
つまり，
\begin{equation}
(\lambdadot{x,y}{\cdots})(a,b) \equiv (\lambdadot{x}{\lambdadot{y}{\cdots}})(a)(b)
\end{equation}
といえる．

これは簡単に拡張が出来て，任意の多変数関数$g$に対してある関数$h$があって
\begin{equation}
g(a_1, a_2, \cdots, a_n)= h(a_1)(a_2)\cdots(a_n)
\end{equation}
となる．
この操作$\mathrm{curry}: g\mapsto h$をカリー化(currying)と呼ぶ．
纏めると，カリー化を行うことにより全ての多変数関数は一変数関数で書くことが出来ることとなる．

このことより，
$\lambdadot{x}{\lambdadot{y}{\lambdadot{z}{\cdots}}}$の略記として
$\lambdadot{x,y,z,\cdots}{}$または
$\lambdadot{xyz\cdots}{}$と書き，
$f(a)(b)(c)\cdots$を
$f(a,b,c\cdots)$と書くことがある．

ここで，二変数の関数に一つだけ引数を与えた\refEq{eq:lambda-curried-partial}のような場合を考える．
\begin{align}
f (x)(y) &= x + y \quad \left(f = \lambdadot{xy}{x + y}\right) \\
\mathit{add3}(x)   &= 3 + x \quad \left(\mathit{add3} = \lambdadot{x}{3 + x}\right) 
\end{align}
なる$f$，$\mathit{add3}$を考えたときに
\begin{align}
\begin{aligned}
f(3)            &= (\lambdadot{x}{\lambdadot{y}{x+y}})(3) \\
                &= \lambdadot{y}{3 + y} \\
                &= \lambdadot{x}{3 + x} \\
                &= \mathit{add3}
\end{aligned}
\end{align}
となって，二つの引数を持つ関数$f$に引数を一つ適用した関数$f(3)$と
常識的な方法で定義した引数に3を加える関数$\mathit{add3}$が等しくなる．
このように$n$の引数を取る関数に対して$m$ ($<n$)の引数を適用することを部分適用(partial application)と呼ぶ．

以下，関数の引数を表す括弧は省略し，
$f(x)(y)(z)\cdots$は$f\ x\ y\ z\ \cdots$または$f x y z \cdots$と書く．

% \section{ラムダ計算}\label{sc:about-lambda-calculus}

% \section{型付ラムダ計算}\label{sc:about-typed-lambda-calculus}

\section{型について}\label{sc:about-type}

ある式$e$が型$t$を持つことを
\begin{equation}
e: t
\end{equation}
と書く．

例えば，真偽値をとる変数$b$があったとき，
その型は真偽値型(\textsf{bool})であると定めることが出来る．

関数$f$と型$t$の式$e:t$があって，$e$に$f$を適用した$f\ e$の型が$s$であるとき，
$f$の型は$t\rightarrow s$であるとする．

\section{目的とする計算機}\label{sc:target-machine}
nibkameコンパイラはターゲットとしてx86機械語を生成する．それの理解のため
に必要となるx86アーキテクチャの機能について説明する．

いわゆるx86は，1978年に発表されたIntel 8086とそれを元に開発された互換性
のあるマイクロプロセッサの総称である．以下では特にIntel Pentium 4プロセッ
サ以降のSSE2命令に対応したものについて扱う．\footnote{詳細について
は，「IA-32 インテル アーキテクチャー・ソフトウェア・デベロッパーズ・マ
ニュアル」を参照のこと(\url{http://www.intel.com/jp/download/index.htm}
から入手できる)．}

\subsection{命令セットの概要}\label{ssc:instruction_set}

\subsection{呼び出し規約}\label{ssc:calling-convention}
呼び出し規約とは，関数や手続きといったサブルーチンとのデータの引き渡し方
法の規約のことをいう．

x86計算機上のC言語で広く用いられる呼び出し規約には次のようなものがある．
\begin{itemize}
 \item cdecl
 \item stdcall
 \item fastcall
\end{itemize}

\subsubsection{cdecl呼び出し規約}
多くのC言語処理系で採用されている方法であり，関数への引数は右から順にス
タックへ積まれ，最後に関数の戻りアドレスを積み関数へ渡す方法である．スタッ
ク上の引数は関数の呼び出し側で破棄を行う必要がある．

この方法を用いると，予め位置の決まっている引数によって後続の引数と種類
を判別できるようにすることで，可変長な引数のサブルーチンを実現することが
できる．このとき，引数の数が既知な呼び出し側が引数のデータ領域を破棄す
ることになるため，次のstdcall呼び出し規約より引数の破棄が容易である．

\subsubsection{stdcall呼び出し規約}
前述のcdecl呼び出し規約と同様に，関数引数は右から順に積み，最後は戻りア
ドレスを積む方法である．しかし，スタック上の引数は呼ばれた関数側が破棄を
行う\footnote{x86命令セットはこのための特化命令を持っている．}．このた
め，可変長な引数を持つ関数の実現は難しくなる．

Win32APIにおいてはこれがデフォルトである\footnote{WinMainなどにつける
WINAPIは，stdcall呼び出し規約を用いることを示す\_\_stdcallに展開されるよう
マクロ定義してある．}．

\subsubsection{fastcall呼び出し規約}
引数の一部をレジスタに置くことで高速化を目指す方法である．引数をレジスタ
やその個数などは処理系により異なる．

x86アーキテクチャにおいては汎用レジスタの本数が少ないためメモリ転送が少な
くなるとは限らず，また処理系間での互換性も低いため，あまり用いられること
はない．

\subsubsection{戻り値の扱い}


\chapter{対象言語の設計}\label{ch:lang_design}

\begin{abstract}
この章では，言語の仕様とその背景，設計思想について述べる．
そして，最終的に実装された言語機能と構文を示す．
\end{abstract}

\section{主要な構文要素}\label{sc:syntax-element}
\subsection{数}\label{sc:syntax-number}
数は整数と実数の二種類があり，この二つは明確に区別される．
いくつか例を挙げると\refTbl{tbl:int-float}のようになる．

\begin{table}[h]
    \caption{整数と実数}\label{tbl:int-float}
    \begin{center}
    \begin{tabular}{crl}
    \Hline
    整数の例&\lstinline|0|& \\
            &\lstinline|1|& \\
            &\lstinline|100|& \\
            &\lstinline|-1|& 負号がついても整数 \\
            &\lstinline|+20|& 正号がついても整数 \\
    \hline
    実数の例 &\lstinline|0.0|& \\
             &\lstinline|1.0|& \\
             &\lstinline|-1.0|& 負号がついても整数 \\
             &\lstinline|+3.14|& 正号がついても整数 \\
             &\lstinline|1.0e10|& 指数表記も可能 \\
             &\lstinline|1.0e+10|& 指数にも正負号を付けられる \\
    \Hline
    \end{tabular}
    \end{center}
\end{table}

\subsection{char}\label{ssc:syntax-char}
nibkameにおいて用意されている組み込みの文字型は
char型であるが，この型は%C言語と同様に
8ビットの符号付き整数である．
%char型であり，計算機上での表現は処理系に依存する．

\section{式}\label{sc:expr}
nibkameにおける式の定義は以下の様になる．
\begin{equation}\label{eq:expr} 
\begin{array}{rcll}
e&\Coloneqq& c                          & \text{定数 (\refSsc{ssc:expr-constant})} \\
 &\mid&  s:\tau                     & \text{外部定数 (\refSsc{ssc:expr-external})} \\
 &\mid&  x                          & \text{変数 (\refSsc{ssc:expr-variable})} \\
 &\mid&  g                          & \text{型構築子 (\refSsc{ssc:expr-constructor})} \\
 &\mid&  \lambdadot{x}{e}           & \text{関数 (\refSsc{ssc:expr-function})} \\
 &\mid&  e, \cdots, e               & \text{組 (\refSsc{ssc:expr-tuple})} \\
 &\mid&  e!                         & \text{参照 (\refSsc{ssc:expr-reference})} \\
 &\mid&  e\ e                       & \text{適用 (\refSsc{ssc:expr-apply})} \\
 &\mid&  \mathnkop{let}x=e\mathnkop{in}e & \text{束縛 (\refSsc{ssc:expr-let})} \\
 &\mid&  \fixdot{f}{\lambdadot{x}{e}} & \text{不動点演算子 (\refSsc{ssc:expr-fix})} \\
 &\mid&  \mathnkop{if}e\mathnkop{then}e\mathnkop{else}e & \text{条件 (\refSsc{ssc:expr-if})} \\
 &\mid&  \mathnkop{match}e\mathnkop{with}\mathit{clss} & \text{条件 (\refSsc{ssc:expr-if})} \\
\mathset{Expr}&\triangleq& \varrange{e}            & \text{式} \\
\mathset{ExprVar}&\triangleq& \varrange{x}            &  \\
\mathset{ExprConst}&\triangleq& \varrange{c}            &  \\
\mathit{cls} &\Coloneqq& p\rightarrow e & \\
             &\mid& p \mathnkop{when} e \rightarrow e & \text{ガード付} \\
\mathset{Clause}&\triangleq& \varrange{\mathit{cls}}            & \text{節} \\
\mathit{clss} &\Coloneqq& \mathit{cls} &\text{} \\
              &\mid& \mathit{clss}|\mathit{cls} &\text{} \\
\mathset{Clauses}&\triangleq& \varrange{\mathit{clss}}            & \text{節の並び} \\
p&\Coloneqq&\_                         & \text{全て} \\
 &\mid&  c                          & \text{定数} \\
 &\mid&  x                          & \text{変数} \\
 &\mid&  g                          & \text{型構築子} \\
 &\mid&  g\ p                       & \text{型構築子適用} \\
 &\mid&  p,\cdots,p                 & \text{組} \\
 &\mid&  p @ p                      & \text{連言} \\
 &\mid&  p | p                      & \text{選言} \\
 &\mid&  \lnot p                    & \text{否定} \\
\mathset{Pattern}&\triangleq& \varrange{p}            & \text{パターン} \\
\mathset{Constructor}&\triangleq& \varrange{g}            & \text{型構築子} \\
\end{array}
\end{equation}

\subsection{定数}\label{ssc:expr-constant}
\subsection{外部定数}\label{ssc:expr-external}
\subsection{変数}\label{ssc:expr-variable}
\subsection{型構築子}\label{ssc:expr-constructor}
\subsection{関数}\label{ssc:expr-function}
\subsection{適用}\label{ssc:expr-apply}
\subsection{組}\label{ssc:expr-tuple}
\subsection{参照}\label{ssc:expr-reference}
\section{型システム}\label{sc:型システム}
nibkameでは型システムとして，Hindley-Milner型システムを採用した．

Hindley-Milner型システムとはHaskellやMLのような静的型付け関数プログラミング言語によく用いられる型システムであり，
「すべての式に一意な最汎(most general)型，即ち主型(principal type)を付けることができる」という重要な性質を持つ．

代表的なアルゴリズムは「\algorithmW」\cite{Milner1978348}\cite{Damas:1982:PTF:582153.582176}として知られているものである．
このアルゴリズムはHindley-MilnerアルゴリズムともDamas-Milnerアルゴリズムとも呼ばれる．
型変数への代入による型の同一化(unification)を基本操作としている．

このアルゴリズムの起源は，Haskell CurryとRobert Feysが1958年に単純型付ラムダ計算の型推論のために考案したものであり，
1969年にJ. Roger Hindleyがそれを拡張し，また，それが常に最汎な型に推論することを証明した．
1978年にRobin MilnerはHindleyとは独立に\algorithmW\cite{Milner1978348}を導き出し，
1982年，Luis Damasが最終的にMilnerのアルゴリズムの完全性を証明した\cite{Damas:1982:PTF:582153.582176}．

今現在，
Hindley-Milner型システムを採用しているnibkameでは型は以下の様に定義される．
\begin{equation}\label{eq:type} 
\begin{array}{rcll}
    \tau    &\Coloneqq& \iota                       & \text{型定数 (\refSsc{ssc:type-constant})} \\
            &\mid&  \alpha                          & \text{型変数 (\refSsc{ssc:type-variable})} \\
            &\mid&  \tau \rightarrow \tau           & \text{関数型 (\refSsc{ssc:type-function})} \\
            &\mid&  \tau \times \cdots \times \tau  & \text{直積型 (\refSsc{ssc:type-tuple})} \\
            &\mid&  \tau\ \textsf{ref}              & \text{参照型 (\refSsc{ssc:type-reference})} \\
            &\mid&  \tau\ \tau                      & \text{型適用 (\refSsc{ssc:type-apply})} \\
    \mathset{Type}&\triangleq& \varrange{\tau}            & \text{型} \\
    \sigma  &\Coloneqq &\tau                            & \text{型} \\
            &\mid&  \foralldot{\alpha}{\sigma}      & \text{全称量化}\\
    \mathset{TypeScheme}&\triangleq& \varrange{\sigma}            & \text{型スキーム}\\
    \mathset{TypeVar}&\triangleq& \varrange{\alpha}            & 
\end{array}
\end{equation}
直和形については型推論部では扱わない．

\subsection{実例}\label{ssc:example}

\subsection{型定数}\label{ssc:type-constant}
nibkameにおいて型定数は次の様に定義される．
\begin{equation}\label{eq:type-constant} 
\begin{array}{rcll}
    \iota   &\Coloneqq& \typename{int}                  & \text{整数型} \\
            &\mid&  \typename{float}                & \text{実数型} \\
            &\mid&  \typename{char}                 & \text{char型} \\
            &\mid&  \typename{list}                 & \text{リスト型} \\
            &\mid&  \typename{array}                & \text{配列型} \\
            &\mid&  \mathit{variant}                & \text{ヴァリアント型} \\
    \mathset{TypeConstant}&\triangleq& \varrange{\iota}            & \text{型定数}\\
    \mathset{TypeVariant}&\triangleq& \varrange{\mathit{variant}}  & \text{ヴァリアント型}
\end{array}
\end{equation}

以上のうち，\typename{int}と\typename{float}は数値を表す型であり，
内部的には夫々マシンにおけるもっとも自然な整数を表す表現\jpdash 例えばレジスタによる整数表現\jpdash と，
もっとも自然な浮動小数点数を表す表現\jpdash 例えばIEEEの浮動小数点数\jpdash が用いられる．
\typename{char}は1バイトによって表現できる符号なし数
\jpdash 典型的には$0$から$2^8-1$\jpdash 
を表す型である．

$\typename{list}$と$\typename{array}$，ヴァリアント型が型定数となっているのに違和感を覚える向きもあるだろうが理由は
\refSsc{ssc:type-apply}で詳説する．

\subsection{型変数}\label{ssc:type-variable}
型変数とは型を動く変数である．

\subsection{関数型}\label{ssc:type-function}
関数型とはその名の通り関数が持つ型であり，
$s$型をとって$t$型を返す関数の型は$s\rightarrow t$となる．

\subsection{直積型}\label{ssc:type-tuple}
\subsection{参照型}\label{ssc:type-reference}

\subsection{型適用}\label{ssc:type-apply}
ML系言語の型には，
$\typename{int}\ \typename{list}$や，
$(\typename{int}\times\typename{char}\ \typename{array})\ \typename{list}$
等の型が存在する
\footnote{
    Haskell，Mirandaではそれぞれ
    $[\typename{Int}]$，
    $[(\typename{Int}, \typename{Array}\ \typename{Char})]$
    となる．
    }
．
これは夫々整数型のリスト，整数と(char型の配列)の組のリストという意味である．

上記の例よりわかるとおり，\typename{list}や\typename{array}などは型を引数として取る型である．
それを実現するために，それらを型を取って型を返す関数の様に扱う．
但し，ML系関数の記法と合わせるために，関数と引数の並びが通常と逆になる．

\subsection{ヴァリアント型}\label{ssc:type-variant}


\subsection{型変数への代入}\label{ssc:type-order}
型についての半順序関係$\succ$を以下の様に定義する．
但し，$i,n\in\N$，$\rho,\sigma,\tau,\upsilon,\sigma_n,\tau_n\in\mathset{Type}$とする．
\begin{subequations}\label{eq:type-order}
\begin{gather}
    \infer[\rulename{SO-Id}]
        {\tau\succ\tau}
        {} \\
    \infer[\rulename{SO-Var}]
        {\alpha\succ\tau}
        {\alpha\in\mathset{TypeVar}} \\
    \infer[\rulename{SO-Fun}]
        {(\rho\rightarrow\sigma)\succ(\tau\rightarrow\upsilon)}
        {\rho\succ\tau & \sigma\succ\upsilon} \\
    \infer[\rulename{SO-Tuple}]
        {
            (\sigma_0\times\sigma_1\times\cdots\times\sigma_n)
            \succ
            (\tau_0\times\tau_1\times\cdots\times\tau_n)
        }
        {\foralldot{i}{\sigma_i\succ\tau_i}} \\
    \infer[\rulename{SO-Ref}]
        {(\sigma\ \textsf{ref})\succ(\tau\ \textsf{ref})}
        {\sigma\succ\tau} \\
    \infer[\rulename{SO-Apply}]
        {(\rho\ \sigma)\succ(\tau\ \upsilon)}
        {\rho\succ\tau & \sigma\succ\upsilon}
\end{gather}
\end{subequations}
$\sigma\succ\tau$のとき，$\sigma$に含まれるいくつかの型変数に対して置換$\Sigma$を適用することで，
$\Sigma\sigma=\tau$となる．


\section{式の持つ型}\label{sc:type-inf}
まず，変数や型変数，型構築子の型の環境は次の様に定義される．
\begin{equation}\label{eq:type-env} 
\begin{array}{rcll}
    \envExpr  &\subset& \mathset{ExprVar}\times\mathset{TypeScheme} & \text{変数の型環境} \\
    \envType  &\subset& \mathset{TypeVar}\times\mathset{TypeScheme} & \text{型変数の型環境} \\
    \envVariant  &\subset& \mathset{TypeVariant}\times\powerset(\mathset{Constructor}\times\mathset{TypeScheme}) & \text{ヴァリアントの型環境} \\
\end{array}
\end{equation}

定数の型を返す関数$\mathfunc{ConstType}:\mathset{ExprConst}\rightarrow\mathset{TypeConst}$は次の様に定義される．
\begin{equation}\label{eq:func-const-type} 
    \mathfunc{ConstType}(c) = \begin{cases}
        \typename{unit} & \text{if $c$ is $\mathnkop{()}$.} \\
        \typename{bool} & \text{if $c$ is $\mathnkop{true}$ or $\mathnkop{false}$.} \\
        \typename{int} & \text{if $c$ is integer.} \\
        \typename{float} & \text{if $c$ is float.} \\
        \typename{char} & \text{if $c$ is char.} \\
        \alpha\ \typename{list} & \text{if $c$ is $\mathnkop{Nil}$. And $\alpha$ is fresh.}
        \end{cases}
\end{equation}

式の持つ型は以下の様に定義される．
但し，断りの無い限り
$i,n\in\N$，
$c\in\mathset{ExprConst}$, 
$x\in\mathset{ExprVar}$，
$e\in\mathset{Expr}$
とする．
\begin{subequations}
\begin{gather}
    \infer[\rulename{Const}]
        {\envExpr;\envType;\envVariant\vdash c:\tau}
        {\tau=\mathfunc{ConstType}(c)}
    \infer[\rulename{Var-i}]
        {\envExpr;\envType;\envVariant\vdash c:\tau}
        {\tau=\mathfunc{ConstType}(c)}
\end{gather}
\end{subequations}
%\section{内部の設計と実装}\label{sc:impl}
%\section{サンプルプログラムと実行結果}\label{sc:sample}
%\section{結論}\label{sc:conclu}

\chapter{コンパイラの設計と実装}\label{ch:impl}

\begin{abstract}
\end{abstract}

\section{構文解析部}\label{sc:impl-parsing}
現在のところ，構文解析部は
解析表現文法(Parsing Expression Grammar, PEG)\cite{Ford:2004:PEG:982962.964011}の
実装であるParsec\cite{Hutton96monadicparser}を
Schemeへ移植したライブラリ\footnote{Gaucheのソースコードに付属}
を用いて書かれている．

\section{型推論部}\label{sc:impl-type-inference}
現在のところ，型推論部は
\algorithmW\cite{Milner1978348}\cite{Damas:1982:PTF:582153.582176}の
CamlLightにおける実装\cite{Lee:1998:PFL:291891.291892}を参考にしつつ
それを拡張して利用した．
型の合一化のアルゴリズムは
\algorithmU\cite{DBLP:books/el/RV01/BaaderS01}
を使用している．

そのため，非常に計算量が大きくなっており，
\cite{DBLP:journals/jfp/HengleinM94}の
第3節にあるような型をもつ関数に対する型推論を
現実的な時間・メモリ使用量で終わらせることが出来ない．

ヴァリアントの扱いは\cite{DBLP:conf/ctcs/Hagino87}を参考にした．


\chapter{サンプルプログラムと実行結果}\label{ch:sample-program}

\chapter{結論}\label{ch:conclude}

%\chapter*{謝辞}
\addcontentsline{toc}{chapter}{謝辞}
\section*{謝辞}
樋口先生にはプロジェクト計画についてご意見をいただきました．大墳先生には発表
資料の作成や発表についてご指導いただきました．牛田先生には予稿などの書法につ
いて助言をいただきました．深謝の意を表します．

\bibliographystyle{jplain}
\bibliography{reference}

\backmatter
\appendix

\end{document}
