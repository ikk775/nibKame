\documentclass[a4paper,titlepage,report,disablejfam]{jsbook}

\usepackage[dvipdfmx]{graphicx}
\usepackage{emp} % 図の描画用
\usepackage[sc,slantedGreek]{mathpazo}
\usepackage{listings}
\usepackage{jlisting}
\usepackage{mathtools} % Ams-TeXの使用
\usepackage{mathrsfs} % 数式フォント
%\usepackage[cmsy]{MnSymbol} % 記号
\usepackage{amssymb,amsthm} % 記号と定理環境
\usepackage{proof} % 証明図
\usepackage{url} % URL
\usepackage{longtable} % 複数ページに亙る長い表
\usepackage{yhmath} % 長い括弧など
\usepackage{tablists}
\usepackage{mathabx}

\input{preamble}

\begin{document}
\title{電子情報工学科実験報告書 \\ 関数型言語の設計と実装}
\author{
\begin{tabular}{llr}
 L班 & 07317 & 小堀 育男 \\
     & 07322 & 酒本 典明
\end{tabular}
}
\date{平成23年2月3日}

\frontmatter

\maketitle

\tableofcontents
\listoffigures
\listoftables
\lstlistoflistings

\newpage

\mainmatter % 序論も本文の内

\chapter{序論}\label{ch:intro}
\begin{abstract}
 本実験課題選定の理由と目的について論じる．また，実装の概要と報告書の構成を述べる．
\end{abstract}

\begin{resbonsiblesection}{目的}{\kobori}
関数型言語の有用性はHughes\cite{hughes1989functional}などにより主張され
ていた．現在では，関数型言語に由来する機能が，C++やJava, C\# など
の言語に取り込まれている．またScala\footnote{\url{http://www.scala-lang.org/}}
やF\#{}\footnote{\url{http://msdn.microsoft.com/ja-jp/fsharp}}
など既存の手続き型言語との連携を強く意識した言語も登場している．

関数型言語に特徴的な機能として第一級の関数やクロージャなどがある．これら
は計算機の命令セットの持つ機能からかけ離れている．こういった機能を持った
言語を設計し，実装することで機能に対する理解を深めることを目標とする．

そのために，我々は静的に強く型付けされる関数型言語nibkameを設計しコンパ
イラを実装した．これは学生実験における参照実装として開発された
MinCaml\cite{住井英二郎:2008-04-24}を基にして開発を行なった．

MinCamlおよびMinCamlコンパイラは簡潔な実装(約2000行ほど)で性能の良いコー
ドを生成することに特徴のある関数型言語である．構文はObjective
Caml\footnote{\url{http://caml.inria.fr/ocaml/}}のサブセットであり,算術演算や
タプル構造，破壊的代入の可能な配列，高階関数，再帰と末尾呼び出し，型推論
などの機能が実現されており，レイトレーシングなどの複雑なプログラムを記述
することができる．MinCamlはプログラム言語処理系の教材として用いられるこ
とを主眼としており，その機能選定は実装を簡潔に保つことを重視して行われた．

簡潔さを保つために，多くのアプリケーションプログラムを記述するときに必須
でない機能は省略された．その中にはMinCamlコンパイラの記述に多く用いられ
ている代数的データ型やパターンマッチングなどが存在する．
nibkameではそういった機能と，その他にも生産性に高い影響を与える機能を追
加することでより実用的な言語を開発することを目指した．
MinCamlコンパイラはターゲットとする計算機としてSPARCとPowerPCをサポート
している．しかし実行する計算機の確保の容易さから，nibkameコンパイラはター
ゲットをx86プロセッサとした．

詳しくは\refCh{ch:lang_design}で述べるが，これらの目標を達成するために次
に挙げる機能の追加を行った．
\begin{itemize}
 \item トップレベル環境における複数の式
 \item 多相関数
 \item 代数的データ型
 \item パターンマッチング
 \item x86アーキテクチャ向け機械語の生成
\end{itemize}
また，これを達成するために，複数の定義をひとまとめに扱うモジュール機構と
3番地形式の中間言語の2番地形式への変換，メモリ管理機構の強化が必要となっ
た．
\end{resbonsiblesection}

\section{実装概要}
コンパイラの主要部分はObjective
Camlを用いて実装した．構文解析部分はScheme
(処理系としては
Gauche\footnote{\url{http://practical-scheme.net/gauche/index-j.html}})
を用いた．実行時ランタイムはC言語にて実装した．
% ここに行数などを含むといいみたい

2011年1月12日時点でのソースコードの全行数は7001行であり，
ソースソードの目的別言語別行数内訳は\refTbl{tbl:sourcecode-lines}のようになっている．

\begin{table}[hbt]
    \caption{ソースコードの行数}\label{tbl:sourcecode-lines}
    \begin{center}
    \begin{tabular}{cllr@{行}}
        \Hline
        \multicolumn{1}{c}{目的} & \multicolumn{2}{c}{言語} & \multicolumn{1}{c}{行数} \\
        \hline
        本体        & O'Caml & 実装             & 4820 \\
	                & O'Caml & インターフェース & 781 \\
	                & Scheme &                  & 337 \\
	                & C言語  &                  & 0 \\
        単体テスト  & O'Caml & 実装             & 1063 \\
        \Hline
    \end{tabular}
    \end{center}
\end{table}

\section{報告書の構成} % ここは内容にあわせて書き換えてください．あと
			  % subsectionはオーバースペックな気が．
\refCh{ch:preparation}ではコンパイラの動作を理解するために必要となる理論
や規則について概説する．本報告書で用いる論理学や集合の記法についても説明
する．
\refCh{ch:lang_design}では，nibkame言語に搭載された機能のうち関数型言語
に特有なものについて説明し，最終的に実装された言語機能と構文を示す．
\refCh{ch:impl}ではコンパイラのモジュール構造と各フェーズの対応を示し，
コンパイラの実装について説明する．
\refCh{ch:sample-program}では実際のnibkameプログラムの例を示し，コンパイラの動作
と得られる目的プログラムについて説明する．
\refCh{ch:conclude}では実装した機能についてまとめ，これからの課題を議論する．

%\mainmatter
%\chapter{原理}\label{ch:原理}

\chapter{準備}\label{ch:preparation}
\begin{abstract}
本報告書で用いる理論・記法について概説する． 
本章で説かれる内容は本報告書で用いられる範囲に限定し，
かつ，直感的な解りやすさを最優先としたため，
論理的に不正確な箇所が多々あるがお赦し願いたい．
\end{abstract}

\begin{resbonsiblesection}{全体的な記法について}{\sakamoto}\label{sc:about-notation}
以下，演算子の結合力を表す際に，
\begin{equation}\label{eq:bonding-strength}
\times \gtrdotrel +
\end{equation}
と表すこととする．
これは，$A\times B + C$という式があったときに$(A\times B)+ C$と解釈することを意味する．

等号系の記号の使い分けは\refTbl{tbl:equal-usage}のようにする．

\begin{table}[hbt]
    \caption{等号系記号の使い分け}\label{tbl:equal-usage}
    \begin{center}
    \begin{tabular}{cp{40zw}}
        \Hline
        \multicolumn{1}{c}{記号} & \multicolumn{1}{c}{目的} \\
        \hline
        $=$ & 通常の等値，即ち数値・真偽値・集合などの等しさを真偽値で表す，または，等しいことを言明する． \\
        $\equiv$ & $=$よりも広い意味で同じであることを表す． \\
        $\defeq$ & 通常の式において左辺の記号が右辺で定義されることを示す．\\
        $\Coloneqq$ & BNFにおいて，左辺の記号が右辺で定義されることを示す．\refSc{sc:about-BNF-form} \\
        \Hline
    \end{tabular}
    \end{center}
\end{table}

変数$e$の動く領域を$\varrange{e}$と表すこととする\footnote{一般的な方法ではない}．

自然数$\N$は0を含むこととする．
\end{resbonsiblesection}

\begin{resbonsiblesection}{集合について}{\sakamoto}\label{sc:about-set}
元として含むことを表す記号として$\in$，$\ni$を用いる.  部分集合を表す記号として$\msubset$，$\msupset$を，真部分集合を表す記号として$\mpsubset$，$\mpsupset$を用いる． 空集合の記号としては$\emptyset$を用いる.

集合$x$の羃集合は$\powerset x$若しくは$\powerset(x)$と書く
\footnote{$2^x$や$\boldsymbol{2}^x$という表記も一般的．}．

順序対若しくは単純に対は，$(x,y)$と表すことにする\footnote{標準的には$\left\langle x,y\right\rangle$である．}．
順序対は
\begin{equation}
(x_0,x_1) = (y_0,y_1) \iff x_0 = y_0 \land x_1 = y_1
\end{equation}
という式によって特徴付けられる．
組は$(x_0,x_1,\cdots,x_n)$と表すことにする\footnote{これも標準的には$\left\langle x_0,x_1,\cdots,x_n\right\rangle$である．}．
順序対と同様に
\begin{equation}
(x_0,x_1,\cdots,x_n) = (y_0,y_1,\cdots,x_n) \iff \foralldot{i\in\{0,1,\cdots,n\}}{x_i = y_i}
\end{equation}
となる．
$(x_0,x_1,\cdots,x_n)$は$(x_i)_{i\in\{0,1,\cdots,n\}}$とも書く．

積集合とはいくつかの集合の要素で組を作ったときの集合のことであり，
\begin{equation}
X_0\times X_1\times\cdots\times X_n\triangleq \{(x_0,x_1,\cdots,x_n)|\foralldot{i\in\{0,1,\cdots,n\}}{x_i\in X_i}\}
\end{equation}
と定義される．
$X_0\times X_1\times\cdots\times X_n$は$\prod_{i\in\{0,1,\cdots,n\}} X_i$とも書く．

標準射影$\pi_i:\left(\prod_{j\in\{0,1,\cdots,n\}} X_j\right)\rightarrow X_i$とは，組または対からその構成要素を取り出す演算であり，
\begin{equation}
\pi_i(X_0\times X_1\times\cdots\times X_n)\triangleq X_i
\end{equation}
である．

順序対の集合$X$\jpdash 例えば，$X=\{(x,y)|x\in\R,y\in\Z\}$など\jpdash は二項関係とも呼ばれ，
その始域$\domain X$，終域$\codomain X$は夫々，
\begin{align}
    \domain X &\triangleq \{\pi_0 x|x\in X\}\\
    \codomain X &\triangleq \{\pi_1 x|x\in X\}
\end{align}
と定義される．
二項関係$R$に対して，始域を集合$C$に限定した二項関係$\{x|x\in R, \pi_0 x\in C\}$を
$\domainrestrict{R}{C}$と書く．

$x_0,x_1,\cdots,x_n$ ($n\in\N$)という並びをを$\vec{x}$と略記する．

\end{resbonsiblesection}

\begin{resbonsiblesection}{論理について}{\sakamoto}\label{sc:about-logic}
真・偽を表すの記号として夫々，$\ltrue$，$\lfalse$を用いる.
論理和・論理積・否定・含意の記号として夫々，$\lor$，$\land$，$\lnot$，$\limpl$を用いる.
変数$x$がその領域$\varrange{x}$を動くとき，
述語$P(x)$が全ての$x$で真になることを$\foralldot{x}{P(x)}$，
述語$P(x)$がある$x$で真になることを$\existsdot{x}{P(x)}$と表す．
$\foralldot{x}{\foralldot{y}{\cdots}}$は$\foralldot{x,y,\cdots}{}$と略記する．
$\exists$も同様．

$\forall$，$\exists$，$\lnot$，$\limpl$は右結合性，
例えば，$\lnot\lnot A\equiv \lnot(\lnot A)$，$A\limpl B\limpl C \equiv A\limpl (B\limpl C)$とする．
夫々の演算子の優先順位は$\lnot\gtrdotrel\land,\lor\gtrdotrel\limpl$となる．

\begin{equation}\label{eq:def-mp}
\infer[\rulename{M.P.}]{\beta}{\alpha & \alpha \limpl \beta}
\end{equation}
は，$\alpha$と$\alpha \limpl \beta$という仮定から，\rulename{M.P.}という推論規則によって$\beta$が導き出されることを表す記法である.
\ref{eq:def-mp}によって定義される推論規則は，推論規則内の$\alpha$，$\beta$に式を代入することによって
\begin{equation}\label{eq:def-mp-instance-1}
\infer[\rulename{M.P.}]{A\land B}{A & A \limpl A\land B}
\end{equation}
や，
\begin{equation}\label{eq:def-mp-instance-2}
\infer[\rulename{M.P.}]{\foralldot{x}{Q(a, x) \limpl P(x)}}{\existsdot{x}{P(x)} & \existsdot{x}{P(x)} \limpl \foralldot{x}{Q(a, x) \limpl P(x)}}
\end{equation}
も表す．
この例における$\alpha$，$\beta$のように，超文脈的に扱われる変数のことをメタ変数(meta-variable)と呼ぶ．


$\Gamma_1,\Gamma_2,\cdots\vdash A_1, A_2,\cdots$は，
主に，$\Gamma_1, \Gamma_2, \cdots$から$A_1, A_2, \cdots$が推論できることを表す記法として用いる.
\end{resbonsiblesection}

\begin{resbonsiblesection}{バッカス・ナウア記法について}{\sakamoto}\label{sc:about-BNF-form}
バッカス・ナウア記法（Backus-Naur Form, BNF）
は文脈自由文法を定義するのに用いられるメタ言語であって，
プログラミング言語の構文記述やデータ構造の記述など，広汎に利用される．
計算機科学でも式として頻繁に用いられるので解説する．

$\Coloneqq$の左辺にある名前は右辺にある式で定義される．
例えば，
\begin{equation}\label{eq:bnf-example-1} 
e\Coloneqq \mathsf{abc}
\end{equation}
というBNFに対しては
\begin{equation}
\varrange{e} = \{\mathsf{abc}\}
\end{equation}
となる．

右辺において$\mid$は「または」の意味を表し，$\mid$で区切られたいずれかの式に当てはまる．例えば，
\begin{equation}\label{eq:bnf-example-2} 
e\Coloneqq \mathsf{a} \mid \mathsf{b} \mid \mathsf{c}
\quad\text{または}\quad
\begin{array}{rcl}
    e    &\Coloneqq& \mathsf{a} \\
            &\mid&   \mathsf{b} \\
            &\mid&   \mathsf{c} 
\end{array}
\end{equation}
というBNFに対しては
\begin{equation}
\varrange{e} = \{\mathrm{a}, \mathrm{b}, \mathrm{c}\}
\end{equation}
となる．

右辺において左辺の記号が使われた場合は再帰となる
\begin{equation}\label{eq:bnf-example-3} 
\begin{array}{rcl}
    e    &\Coloneqq& \mathsf{a} \\
            &\mid&   e\mathsf{'} 
\end{array}
\end{equation}
というBNFに対しては
\begin{equation}
\varrange{e} = \{\mathrm{a}, \mathrm{a'}, \mathrm{a''}, \mathrm{a'''}, \cdots \}
\end{equation}
となる．
\end{resbonsiblesection}

\begin{resbonsiblesection}{ラムダ式について}{\sakamoto}\label{sc:about-lambda-expression}
ラムダ式(lambda expression，$\lambda$-expression) とは，一言で言ってしまうと関数そのものを抽象化したものである．

例えば以下の式を考えよう．
\begin{align}
f(x) &= (x + 1)^2\\
f(x + 1) &= {\left((x + 1) + 1\right)}^2 = x^2 + 4x + 4\\
(x + 1) &= x + 1
\end{align}
これは$(x + 1)$に対して関数$f$を適用すると$x^2 + 2x + 1$となるが，
関数を適用しないとそれは$x + 1$そのものであることを表している．

では逆に，$f$に引数を適用しないとどうなるのであろうか．
\begin{align}
f(x) &= x^2 + 2x + 1\\
f    &= \;?
\end{align}
この場合の$f$そのものを表すのにラムダ式を用いることが出来，そうすると
\begin{align}
f &= \lambdadot{x}{(x^2 + 2x + 1)}
\end{align}
となって関数そのものを陽に扱うことが出来る．
以下，必要の無い限り括弧は省略し，$\lambdadot{x}{(x^2 + 2x + 1)}$は$\lambdadot{x}{x^2 + 2x + 1}$と書く．

ラムダ式を用いて記述した関数に引数を適用させると，
\begin{align}
f(y) &= (\lambdadot{x}{x^2 + 2x + 1})(y) = y^2 + 2y + 2 \\
f(2) &= (\lambdadot{x}{x^2 + 2x + 1})(2) = 2^2 + 2\cdot 2 + 1 = 9
\end{align}
となる．

次に複数引数の関数を考えよう．
\begin{align}
g(x, y) &= x + y
\end{align}
この関数を表すためには，
$\lambdadot{x,y}{}$という記法を導入するのが良いと思われる．
従って，
\begin{align}
\label{eq:lambda-multiple}
g &= \lambdadot{x,y}{x + y}\\
\label{eq:lambda-multiple-inst}
g(a, b) &= a + b\\
g(1, 2) &= (\lambdadot{x,y}{x + y})(1, 2) = 1 + 2 = 3
\end{align}
と表せる．

ここで，天下り的ではあるが，$\lambdadot{x}{\lambdadot{y}{x+y}}$を考える．
すると，
\begin{gather}
\begin{aligned}
\label{eq:lambda-curried}
h &= \lambdadot{x}{\lambdadot{y}{x+y}} \\
\end{aligned} \\
\begin{aligned}
\label{eq:lambda-curried-partial}
h(a) &= (\lambdadot{x}{\lambdadot{y}{x+y}})(a)\\
     &= {\lambdadot{y}{a+y}}
\end{aligned} \\
\begin{aligned}
\label{eq:lambda-curried-inst}
\left(h(a)\right)(b) &= \left((\lambdadot{x}{\lambdadot{y}{x+y}})(a)\right)(b) \\
        &= (\lambdadot{y}{a+y})(b)\\
        &= a + b
\end{aligned} \\
\begin{aligned}
\left(h(1)\right)(2) &= \left((\lambdadot{x}{\lambdadot{y}{x+y}})(1)\right)(2) \\
        &= (\lambdadot{y}{1+y})(2) \\
        &= 1 + 2 = 3
\end{aligned}
\end{gather}
このようになる．
以下，$f(a)(b)(c)\cdots$は
$\delimitershortfall-1pt\left({\cdots\left({\left({\left({f(a)}\right)(b)}\right)(c)}\right)\cdots}\right)$
を表すものとし，
必要の無い限り括弧を省略する．

ここで，
\refEq{eq:lambda-multiple-inst}と\refEq{eq:lambda-curried-inst}
を見比べると$g(a, b) = h(a)(b)$であることがわかる．
つまり，
\begin{equation}
(\lambdadot{x,y}{\cdots})(a,b) \equiv (\lambdadot{x}{\lambdadot{y}{\cdots}})(a)(b)
\end{equation}
といえる．

これは簡単に拡張が出来て，任意の多変数関数$g$に対してある関数$h$があって
\begin{equation}
g(a_1, a_2, \cdots, a_n)= h(a_1)(a_2)\cdots(a_n)
\end{equation}
となる．
この操作$\mathrm{curry}: g\mapsto h$をカリー化(currying)と呼ぶ．
纏めると，カリー化を行うことにより全ての多変数関数は一変数関数で書くことが出来ることとなる．

このことより，
$\lambdadot{x}{\lambdadot{y}{\lambdadot{z}{\cdots}}}$の略記として
$\lambdadot{x,y,z,\cdots}{}$または
$\lambdadot{xyz\cdots}{}$と書き，
$f(a)(b)(c)\cdots$を
$f(a,b,c\cdots)$と書くことがある．

ここで，二変数の関数に一つだけ引数を与えた\refEq{eq:lambda-curried-partial}のような場合を考える．
\begin{align}
f (x)(y) &= x + y \quad \left(f = \lambdadot{xy}{x + y}\right) \\
\mathit{add3}(x)   &= 3 + x \quad \left(\mathit{add3} = \lambdadot{x}{3 + x}\right) 
\end{align}
なる$f$，$\mathit{add3}$を考えたときに
\begin{align}
\begin{aligned}
f(3)            &= (\lambdadot{x}{\lambdadot{y}{x+y}})(3) \\
                &= \lambdadot{y}{3 + y} \\
                &= \lambdadot{x}{3 + x} \\
                &= \mathit{add3}
\end{aligned}
\end{align}
となって，二つの引数を持つ関数$f$に引数を一つ適用した関数$f(3)$と
常識的な方法で定義した引数に3を加える関数$\mathit{add3}$が等しくなる．
このように$n$の引数を取る関数に対して$m$ ($<n$)の引数を適用することを部分適用(partial application)と呼ぶ．

以下，関数の引数を表す括弧は省略し，
$f(x)(y)(z)\cdots$は$f\ x\ y\ z\ \cdots$または$f x y z \cdots$と書く．
\end{resbonsiblesection}

% \section{ラムダ計算}\label{sc:about-lambda-calculus}

% \section{型付ラムダ計算}\label{sc:about-typed-lambda-calculus}

\begin{resbonsiblesection}{型について}{\sakamoto}\label{sc:about-type}

ある式$e$が型$t$を持つことを
\begin{equation}
e: t
\end{equation}
と書く．

例えば，真偽値をとる変数$b$があったとき，
その型は真偽値型(\textsf{bool})であると定めることが出来る．

関数$f$と型$t$の式$e:t$があって，$e$に$f$を適用した$f\ e$の型が$s$であるとき，
$f$の型は$t\rightarrow s$であるとする．
\end{resbonsiblesection}

\begin{resbonsiblesection}{目的とする計算機}{\kobori}\label{sc:target-machine}
nibkameコンパイラはターゲットとしてx86機械語を生成する．それの理解のため
に必要となるx86アーキテクチャの機能について説明する．

いわゆるx86は，1978年に発表されたIntel 8086とそれを元に開発された互換性
のあるマイクロプロセッサの総称である．以下では特にIntel Pentium 4プロセッ
サ以降のSSE2命令に対応したものについて扱う．\footnote{詳細について
は，「IA-32 インテル アーキテクチャー・ソフトウェア・デベロッパーズ・マ
ニュアル」を参照のこと(\url{http://www.intel.com/jp/download/index.htm}
から入手できる)．}

\subsection{命令セットの概要}\label{ssc:instruction_set}
nibkameコンパイラが対象とするx86アーキテクチャは，8本の32ビット幅汎用レ
ジスタとプログラムカウンタ(EIPという)，フラグレジスタ(EFLAGS)を持つ．ま
た，浮動小数点数を格納するXMMレジスタ\footnote{本来は短いベクトル命令の
為に用いるが，今回は使用しないため本報告書では触れない．}が8本ある．

汎用レジスタの名前と機能を次に示す．
\begin{description}
 \item[EAX] アキュームレータ．関数の戻り値の格納に用いる．一部の命令では
	    命令長が短くなる．
 \item[EBX] ベースレジスタ．相対アドレッシングのベースに用いられることが
	    多い．
 \item[ECX] カウントレジスタ．一部ではループカウンタとして用いられる．
 \item[EDX] データレジスタ．一時的なデータの保管用に使われることが多い．
 \item[ESI] ソースインデックス．転送元アドレスの格納に多く用いられる．
 \item[EDI] ディスティネーションインデックス．転送先アドレスの格納に多く
	    用いられる．
 \item[ESP] スタックポインタ．命令で直接操作されるスタック（マシンスタッ
	    ク）を指すために用いる．ユーザプログラムでは原則的に他の用途
	    に用いてはならない．
 \item[EBP] ベースポインタ．ローカル変数の領域（スタックフレーム）にアク
	    セスするためのポインタ（フレームポインタ）として用いられる．
	    他の用途に用いるべきではない． 
\end{description}

\subsection{呼び出し規約}\label{ssc:calling-convention}
呼び出し規約とは，関数や手続きといったサブルーチンとのデータの引き渡し方
法の規約のことをいう．

x86計算機上のC言語で広く用いられる呼び出し規約には次のようなものがある．
\begin{itemize}
 \item cdecl
 \item stdcall
 \item fastcall
\end{itemize}

\subsubsection{cdecl呼び出し規約}
多くのC言語処理系で採用されている方法であり，関数への引数は右から順にス
タックへ積まれ，最後に関数の戻りアドレスを積み関数へ渡す方法である．スタッ
ク上の引数は関数の呼び出し側で破棄を行う必要がある．

この方法を用いると，予め位置の決まっている引数によって後続の引数と種類
を判別できるようにすることで，可変長な引数のサブルーチンを実現することが
できる．このとき，引数の数が既知な呼び出し側が引数のデータ領域を破棄す
ることになるため，次のstdcall呼び出し規約より引数の破棄が容易である．

\subsubsection{stdcall呼び出し規約}
前述のcdecl呼び出し規約と同様に，関数引数は右から順に積み，最後は戻りア
ドレスを積む方法である．しかし，スタック上の引数は呼ばれた関数側が破棄を
行う\footnote{x86命令セットはこのための特化命令を持っている．}．このた
め，可変長な引数を持つ関数の実現は難しくなる．

Win32APIにおいてはこれがデフォルトである\footnote{WinMainなどにつける
WINAPIは，stdcall呼び出し規約を用いることを示す\_\_stdcallに展開されるよう
マクロ定義してある．}．

\subsubsection{fastcall呼び出し規約}
引数の一部をレジスタに置くことで高速化を目指す方法である．引数をレジスタ
やその個数などは処理系により異なる．

x86アーキテクチャにおいては汎用レジスタの本数が少ないためメモリ転送が少な
くなるとは限らず，また処理系間での互換性も低いため，あまり用いられること
はない．

\subsubsection{戻り値の扱い}
どの呼び出し規約についても共通に，戻り値は，汎用レジスタに格納できるもの
は，EAXレジスタに格納する．2倍長の場合にはEDX:EAXレジスタ対へ格納する．

構造体などレジスタに格納できない値のときは次のように行う．
\begin{enumerate}
 \item 関数の呼び出し側が，戻り値を格納できる領域を確保する．
 \item 全ての引数の後に確保した領域のアドレスを積む．
 \item 関数は，指定されたアドレスに戻り値を格納する．
 \item EAXレジスタに戻り値を格納した領域のアドレスを格納する．
\end{enumerate}

浮動小数点数を返すときは，使用する命令の種類によって2種類にわかれ
る．\textbf{FPU命令を用いるとき} FPUスタックのトップへ積む．
\textbf{SSE2命令を用いるとき} XMM0レジスタの下位ビット側に格納する．

\subsubsection{手続き呼び出しとレジスタ}
実行に必要な汎用レジスタは，関数の呼び出し側が保存するレジスタ
(caller-save register)と呼ばれた関数が保存するレジスタ(callee-save
register)の2種類にわけられる．その分類を\refTbl{tb:register-save}に表す．
\begin{table}[htb]
\begin{center}
 \caption{レジスタの保存すべき場所}\label{tb:register-save}
 \begin{tabular}{l|l}
  \Hline
  callee-save register & caller-save register \\
  \hline
  EBX & EAX \\
  ESI & EDX \\
  EDI & ECX \\
  EBP & 全てのXMMレジスタ \\
  ESP & \\
  \Hline
 \end{tabular}
\end{center}
\end{table}
\end{resbonsiblesection}

\chapter{対象言語の設計}\label{ch:lang_design}

\begin{abstract}
この章では，
まずnibkame言語のコア部分の仕様を定義し，
後に，その拡張としてnibkame言語本体とライブラリの仕様について述べる．
そして，最終的に実装された言語機能と構文を示す．
\end{abstract}

\begin{resbonsiblesection}{主要な構文要素}{\sakamoto}\label{sc:syntax-element}
\subsection{数}\label{sc:syntax-number}
数は整数と実数の二種類があり，この二つは明確に区別される．
いくつか例を挙げると\refTbl{tbl:int-float}のようになる．

\begin{table}[h]
    \caption{整数と実数}\label{tbl:int-float}
    \begin{center}
    \begin{tabular}{crl}
    \Hline
    整数の例&\lstinline|0|& \\
            &\lstinline|1|& \\
            &\lstinline|100|& \\
            &\lstinline|-1|& 負号がついても整数 \\
            &\lstinline|+20|& 正号がついても整数 \\
    \hline
    実数の例 &\lstinline|0.0|& \\
             &\lstinline|1.0|& \\
             &\lstinline|-1.0|& 負号がついても整数 \\
             &\lstinline|+3.14|& 正号がついても整数 \\
             &\lstinline|1.0e10|& 指数表記も可能 \\
             &\lstinline|1.0e+10|& 指数にも正負号を付けられる \\
    \Hline
    \end{tabular}
    \end{center}
\end{table}

\subsection{char}\label{ssc:syntax-char}
nibkameにおいて用意されている組み込みの文字型は
char型であるが，この型は%C言語と同様に
8ビットの符号無し整数である．
%char型であり，計算機上での表現は処理系に依存する．
\end{resbonsiblesection}

\begin{resbonsiblesection}{式の構文}{\sakamoto}\label{sc:expr-syntax}
nibkameにおける式の定義は以下の様になる．
\begin{equation}\label{eq:expr} 
\begin{array}{rcll}
e&\Coloneqq& c                          & \text{定数 (\refSsc{ssc:expr-constant})} \\
 &\mid&  s:\tau                     & \text{外部定数 (\refSsc{ssc:expr-external})} \\
 &\mid&  v                          & \text{変数 (\refSsc{ssc:expr-variable})} \\
 &\mid&  g                          & \text{型構築子 (\refSsc{ssc:expr-constructor})} \\
 &\mid&  \fundot{x}{e}           & \text{関数 (\refSsc{ssc:expr-function})} \\
 &\mid&  e, \cdots, e               & \text{組 (\refSsc{ssc:expr-tuple})} \\
 &\mid&  e!                         & \text{参照 (\refSsc{ssc:expr-reference})} \\
 &\mid&  e\coloneq e                & \text{代入 (\refSsc{ssc:expr-reference})} \\
 &\mid&  e\ e                       & \text{適用 (\refSsc{ssc:expr-apply})} \\
 &\mid&  \mathnkop{let}x=e\mathnkop{in}e & \text{束縛 (\refSsc{ssc:expr-let})} \\
 &\mid&  \fixdot{f}{\fundot{x}{e}} & \text{不動点演算子 (\refSsc{ssc:expr-fix})} \\
% &\mid&  \mathnkop{if}e\mathnkop{then}e\mathnkop{else}e & \text{条件 (\refSsc{ssc:expr-if})} \\
 &\mid&  \mathnkop{match}e\mathnkop{with}\mathit{clss}\clauseor\patternany\rightarrow e & \text{パターンマッチング (\refSsc{ssc:expr-match})} \\
\mathset{Expr}&\triangleq& \varrange{e}            & \text{式} \\
\mathset{ExprVar}&\triangleq& \varrange{x}            &  \\
\mathset{ExprConst}&\triangleq& \varrange{c}            &  \\
\mathit{cls} &\Coloneqq& p\rightarrow e & \\
             &\mid& p \mathnkop{when} e \rightarrow e & \text{ガード付} \\
\mathit{clss} &\Coloneqq& \mathit{cls} & \\
              &\mid& \mathit{clss}\clauseor\mathit{cls} & \\
\mathset{Clause}&\triangleq& \varrange{\mathit{cls}}            & \text{節} \\
\mathset{Clauses}&\triangleq& \varrange{\mathit{clss}}            & \text{節の並び} \\
p&\Coloneqq&\patternany             & \text{全て} \\
 &\mid&  c                          & \text{定数} \\
 &\mid&  x                          & \text{変数} \\
 &\mid&  g                          & \text{型構築子} \\
 &\mid&  g\ p                       & \text{型構築子適用} \\
 &\mid&  p,\cdots,p                 & \text{組} \\
 &\mid&  p \patternand p            & \text{連言} \\
 &\mid&  p \patternor p             & \text{選言} \\
 &\mid&  \lnot p                    & \text{否定} \\
\mathset{Pattern}&\triangleq& \varrange{p}            & \text{パターン} \\
\mathset{Constructor}&\triangleq& \varrange{g}            & \text{型構築子} \\
\mathset{Var}&\triangleq&\mathset{ExprVar}\cup\mathset{Constructor}
\end{array}
\end{equation}
ここで，$\mathset{ExprVar}\cap\mathset{Constructor}=\emptyset$である．

\subsection{定数}\label{ssc:expr-constant}
定数とは
\begin{itemize}
    \item \lstinline|()|
    \item \lstinline|Nil|
    \item 整数
    \item 浮動小数点数
    \item 文字
\end{itemize}
の五つである．

このうち，\lstinline|()|はC言語で言うところのvoidのようなもので，
関数が引数を取らない若しくは返さないことを明示するのに用いる．
\lstinline|Nil|はC言語で言うところのNULLのようなもので，
リストの末尾であることを示す．

\subsection{外部定数}\label{ssc:expr-external}

\subsection{変数}\label{ssc:expr-variable}
変数は一般のプログラミング言語における概念と同じである．
しかし，nibkameにおける変数は生成時に行われる束縛の後は一切の代入を行うことが出来ない．

\subsection{型構築子}\label{ssc:expr-constructor}
\subsection{関数}\label{ssc:expr-function}
\subsection{適用}\label{ssc:expr-apply}
\subsection{組}\label{ssc:expr-tuple}
\subsection{参照}\label{ssc:expr-reference}
\end{resbonsiblesection}
\begin{resbonsiblesection}{型の構文}{\sakamoto}\label{sc:type-syntax}
nibkameでは型システムとして，Hindley-Milner型システムを採用した．

Hindley-Milner型システムとはHaskellやMLのような静的型付け関数プログラミング言語によく用いられる型システムであり，
「すべての式に一意な最汎(most general)型，即ち主型(principal type)を付けることができる」という重要な性質を持つ．

代表的なアルゴリズムは「\algorithmW」\cite{Milner1978348}\cite{Damas:1982:PTF:582153.582176}として知られているものである．
このアルゴリズムはHindley-MilnerアルゴリズムともDamas-Milnerアルゴリズムとも呼ばれる．
型変数への代入による型の同一化(unification)を基本操作としている．

このアルゴリズムの起源は，Haskell CurryとRobert Feysが1958年に単純型付ラムダ計算の型推論のために考案したものであり，
1969年にJ. Roger Hindleyがそれを拡張し，また，それが常に最汎な型に推論することを証明した．
1978年にRobin MilnerはHindleyとは独立に\algorithmW\cite{Milner1978348}を導き出し，
1982年，Luis Damasが最終的にMilnerのアルゴリズムの完全性を証明した\cite{Damas:1982:PTF:582153.582176}．

今現在，
Hindley-Milner型システムを採用しているnibkameでは型は以下の様に定義される．
\begin{equation}\label{eq:type} 
\begin{array}{rcll}
    \tau    &\Coloneqq& \iota                       & \text{型定数 (\refSsc{ssc:type-constant})} \\
            &\mid&  \alpha                          & \text{型変数 (\refSsc{ssc:type-variable})} \\
            &\mid&  \tau \rightarrow \tau           & \text{関数型 (\refSsc{ssc:type-function})} \\
            &\mid&  \tau \times \cdots \times \tau  & \text{直積型 (\refSsc{ssc:type-tuple})} \\
            &\mid&  \tau\ \textsf{ref}              & \text{参照型 (\refSsc{ssc:type-reference})} \\
            &\mid&  \tau\ \tau                      & \text{型適用 (\refSsc{ssc:type-apply})} \\
    \mathset{Type}&\triangleq& \varrange{\tau}            & \text{型} \\
    \sigma  &\Coloneqq &\tau                            & \text{型} \\
            &\mid&  \foralldot{\vec{\alpha}}{\tau}      & \text{全称量化}\\
    \mathset{TypeScheme}&\triangleq& \varrange{\sigma}            & \text{型スキーム}\\
    \mathset{TypeVar}&\triangleq& \varrange{\alpha}            & 
\end{array}
\end{equation}

\subsection{実例}\label{ssc:example}

\subsection{型定数}\label{ssc:type-constant}
nibkameにおいて型定数は次の様に定義される．
\begin{equation}\label{eq:type-constant} 
\begin{array}{rcll}
    \iota   &\Coloneqq& \typename{int}                  & \text{整数型} \\
            &\mid&  \typename{float}                & \text{実数型} \\
            &\mid&  \typename{char}                 & \text{char型} \\
            &\mid&  \typename{list}                 & \text{リスト型} \\
            &\mid&  \typename{array}                & \text{配列型} \\
            &\mid&  \mathit{variant}                & \text{ヴァリアント型} \\
    \mathset{TypeConstant}&\triangleq& \varrange{\iota}            & \text{型定数}\\
    \mathset{TypeVariant}&\triangleq& \varrange{\mathit{variant}}  & \text{ヴァリアント型}
\end{array}
\end{equation}

以上のうち，\typename{int}と\typename{float}は数値を表す型であり，
内部的には夫々マシンにおけるもっとも自然な整数を表す表現\jpdash 例えばレジスタによる整数表現\jpdash と，
もっとも自然な浮動小数点数を表す表現\jpdash 例えばIEEEの浮動小数点数\jpdash が用いられる．
\typename{char}は1バイトによって表現できる符号なし数
\jpdash 典型的には$0$から$2^8-1$\jpdash 
を表す型である．

$\typename{list}$と$\typename{array}$，ヴァリアント型が型定数となっているのに違和感を覚える向きもあるだろうが理由は
\refSsc{ssc:type-apply}で詳説する．

\subsection{型変数}\label{ssc:type-variable}
型変数とは型を動く変数である．

\subsection{関数型}\label{ssc:type-function}
関数型とはその名の通り関数が持つ型であり，
$s$型をとって$t$型を返す関数の型は$s\rightarrow t$となる．

\subsection{直積型}\label{ssc:type-tuple}
\subsection{参照型}\label{ssc:type-reference}

\subsection{型適用}\label{ssc:type-apply}
ML系言語の型には，
$\typename{int}\ \typename{list}$や，
$(\typename{int}\times\typename{char}\ \typename{array})\ \typename{list}$
等の型が存在する
\footnote{
    Haskell，Mirandaではそれぞれ
    $[\typename{Int}]$，
    $[(\typename{Int}, \typename{Array}\ \typename{Char})]$
    となる．
    }
．
これは夫々整数型のリスト，整数と(char型の配列)の組のリストという意味である．

上記の例よりわかるとおり，\typename{list}や\typename{array}などは型を引数として取る型である．
それを実現するために，それらを型を取って型を返す関数の様に扱う．
但し，ML系関数の記法と合わせるために，関数と引数の並びが通常と逆になる．

\subsection{ヴァリアント型}\label{ssc:type-variant}


\subsection{型変数への代入}\label{ssc:type-order}
$\tau$に含まれるいくつかの型変数に対して置換$\substType$を適用することで，
$\Sigma\tau=\tau'$となるとき，
$\tau\succ\tau'$とかく．
この$\succ$は半順序となる．
$\tau\succ\tau'$かつ$\tau'\succ\tau$のとき型$\tau$，$\tau'$は$\alpha$等値といい，
$\tau\mathrel{\overset{\alpha}{=}}\tau'$と表す．
\end{resbonsiblesection}


\begin{resbonsiblesection}{意味論}{\sakamoto}\label{sc:semantics}
まず，変数や型変数，型構築子の型の環境は次の様に定義される．
\begin{equation}\label{eq:env} 
\begin{array}{rcll}
    \envExpr  &\subset& \mathset{Var}\times\mathset{TypeScheme} & \text{変数の型環境} \\
    \envType  &\subset& \mathset{TypeVar}\times\mathset{TypeScheme} & \text{型変数の型環境} \\
    \envVariant  &\subset& \mathset{TypeVariant}\times\powerset(\mathset{Constructor}\times\mathset{TypeScheme}) & \text{ヴァリアントの型環境} \\
\end{array}
\end{equation}
%置換の集合は次のように定義される．
%\begin{equation}\label{eq:subst} 
%\begin{array}{rcll}
%    \substExpr  &\subset& \mathset{Var}\times\mathset{Expr} & \text{変数の置換} \\
%    \substType  &\subset& \mathset{TypeVar}\times\mathset{Type} & \text{型変数の置換} \\
%\end{array}
%\end{equation}
%置換の集合については特別に$\{(v,e),\cdots\}$を$[e/v,\cdots]$とも書く．
式$e$，型$\tau$の中に現れる自由変数の集合は夫々$\freevars{e}$，$\freetypevars{\tau}$と書く．

%式に対する置換の適用$\applysubst{\Sigma}{x}$は次のように定義される．
%\begin{equation}
%\begin{aligned}
%    \applysubst{\substExpr}{c} &= c \\
%    \applysubst{\substExpr}{s:\tau} &= s:\tau \\
%    \applysubst{\substExpr}{x} &=\begin{cases}
%        e & \text{if $(v,e)\in\substExpr$.} \\
%        x & \text{otherwise.} \end{cases} \\
%    \applysubst{\substExpr}{\fundot{x}{e}} &= \applysubst{\substExpr'}{e} &
%            \text{which $\substExpr' = \domainrestrict{\substExpr}{(\domain\substExpr\setminus\{x\})}$.}\\
%\end{aligned}
%\end{equation}

\subsection{型}\label{sc:type}
定数の型を返す関数$\mathfunc{ConstType}:\mathset{ExprConst}\rightarrow\mathset{TypeConst}$は次の様に定義される．
\begin{equation}\label{eq:func-const-type} 
    \mathfunc{ConstType}(c) = \begin{cases}
        \typename{unit} & \text{if $c$ is $\mathnkop{()}$.} \\
        \typename{bool} & \text{if $c$ is $\mathnkop{true}$ or $\mathnkop{false}$.} \\
        \typename{int} & \text{if $c$ is integer.} \\
        \typename{float} & \text{if $c$ is float.} \\
        \typename{char} & \text{if $c$ is char.} \\
        \alpha\ \typename{list} & \text{if $c$ is $\mathnkop{Nil}$. And $\alpha$ is fresh.}
        \end{cases}
\end{equation}

パターンによる束縛の型環境$\patternandenv{p:\tau}{\envPattern}$は以下の様に定義される．
\begin{subequations}
\begin{gather}
    \infer[\rulename{P-All}]
        {\envExpr\vdash \patternandenv{\_:\tau}{\emptyset}}
        {}\\
    \infer[\rulename{P-Not}]
        {\envExpr\vdash \patternandenv{\lnot p:\tau}{\emptyset}}
        {\envExpr\vdash \patternandenv{p:\tau}{\envPattern}}\\
    \infer[\rulename{P-Const}]
        {\envExpr\vdash \patternandenv{c:\tau}{\emptyset}}
        {\mathfunc{ConstType}(c) \succ \tau} \\
    \infer[\rulename{P-Var}]
        {\envExpr\vdash \patternandenv{x:\tau}{\{x:\tau\}}}
        {x\in\mathset{ExprVar}}\\
    \infer[\rulename{P-Constructor}]
        {\envExpr\vdash \patternandenv{g:\tau}{\emptyset}}
        {g\in\mathset{Constructor} & (g,\tau)\in\envExpr & \tau_1\rightarrow\tau_2\not\succ\tau}\\
    \infer[\rulename{P-Apply}]
        {\envExpr\vdash \patternandenv{g\ p:\tau}{\envPattern}}
        {g\in\mathset{Constructor} & (g,\tau'\rightarrow\tau )\in\envExpr & \envExpr\vdash \patternandenv{p:\tau'}{\envPattern} }\\
    \infer[\rulename{P-Tuple}]
        {\envExpr\vdash \patternandenv{e_0,\cdots,e_n:\tau_0\times\cdots\times\tau_n}{\bigcup_i \envPattern_i}}
        {\envExpr\vdash\patternandenv{p_0:\tau_0}{\envPattern_0} &
        \cdots &
        \envExpr\vdash\patternandenv{p_n:\tau_n}{\envPattern_n} &
        \foralldot{i,j}{i\not= j\limpl (\domain\envPattern_i \cap \domain\envPattern_j = \emptyset)}}\\
    \infer[\rulename{P-And}]
        {\envExpr\vdash \patternandenv{p_1 @ p_2:\tau}{\envPattern_1\cap\envPattern_2}}
        {\envExpr\vdash \patternandenv{p_1:\tau}{\envPattern_1} &
        \envExpr\vdash \patternandenv{p_2:\tau}{\envPattern_2} &
        \domain\envPattern_1 \cap \domain\envPattern_2 = \emptyset
        }\\
    \infer[\rulename{P-Or}]
        {\envExpr\vdash \patternandenv{p_1 \patternor p_2:\tau}{\envPattern}}
        {\envExpr\vdash \patternandenv{p_1:\tau}{\envPattern} &
        \envExpr\vdash \patternandenv{p_2:\tau}{\envPattern}}
\end{gather}
\end{subequations}
式の持つ型は以下の様に定義される．
但し，断りの無い限り
%$i,n\in\N$，
$c\in\mathset{ExprConst}$, 
$x,v\in\mathset{ExprVar}$，
$e\in\mathset{Expr}$
とする．
\begin{subequations}
\begin{gather}
    \infer[\rulename{E-Const}]
        {\envExpr\vdash c:\tau}
        {\mathfunc{ConstType}(c) \succ \tau} \\
    \infer[\rulename{E-Var}]
        {\envExpr\vdash v:\tau}
        {(v,\tau')\in\envExpr & \tau' \succ \tau}\\
    \infer[\rulename{E-Fun}]
        {\envExpr\vdash \fundot{x}{e}:\tau_1\rightarrow\tau_2}
        {\envExpr+(x,\tau_1)\vdash e:\tau_2}\\
    \infer[\rulename{E-Tuple}]
        {\envExpr\vdash e_0,\cdots,e_n:\tau_0\times\cdots\times\tau_n}
        {\envExpr\vdash e_0:\tau_0 &
        \cdots &
        \envExpr\vdash e_n:\tau_n}\\
    \infer[\rulename{E-Ref}]
        {\envExpr\vdash e!:\tau}
        {\envExpr\vdash e:\tau\ \mathsf{ref}}\\
    \infer[\rulename{E-Set}]
        {\envExpr\vdash e_1\coloneq e_2:\typename{unit}}
        {\envExpr\vdash e_1:\tau\ \mathsf{ref} &
        \envExpr\vdash e_2:\tau}\\
    \infer[\rulename{E-Apply}]
        {\envExpr\vdash e_1\ e_2:\tau}
        {\envExpr\vdash e_1:\tau'\rightarrow\tau &
        \envExpr\vdash e_2:\tau'} \\
    \infer[\rulename{E-Let}]
        {\envExpr\vdash \mathnkop{let}x=e_1\mathnkop{in}e_2:\tau}
        {\envExpr\vdash e_1:\tau' &
        \envExpr+(x,\tau')\vdash e_2:\tau}\\
%    \infer[\rulename{E-If}]
%        {\envExpr\vdash \mathnkop{if}e_1\mathnkop{then}e_2\mathnkop{else}e_3:\tau}
%        {\envExpr\vdash e_1:\typename{bool} &
%        \envExpr\vdash e_2:\tau &
%        \envExpr\vdash e_3:\tau}\\
    \infer[\rulename{E-Fix}]
        {\envExpr\vdash \fixdot{f}e:\tau}
        {\envExpr+(f,\tau)\vdash e:\tau}\\
    \infer[\rulename{E-Match}]
        {\envExpr\vdash \mathnkop{match}e\mathnkop{with}\mathit{clss}:\tau}
        {\envExpr\vdash e:\tau' &
        \envExpr\vdash \mathit{clss}:\tau'\rightarrow\tau}
\end{gather}
\end{subequations}
節の型は以下の様に定義される．
\begin{subequations}
\begin{gather}
    \infer[\rulename{C-Always}]
        {\envExpr\vdash p\rightarrow e:\tau'\rightarrow\tau}
        {\envExpr\vdash \patternandenv{p:\tau'}{\envPattern} &
        \envExpr+\envPattern\vdash e:\tau}\\
    \infer[\rulename{C-Guarded}]
        {\envExpr\vdash p\mathnkop{with}e_g\rightarrow e:\tau'\rightarrow\tau}
        {\envExpr\vdash \patternandenv{p:\tau'}{\envPattern} &
        \envExpr+\envPattern\vdash e_g:\typename{bool} &
        \envExpr+\envPattern\vdash e:\tau}\\
    \infer[\rulename{C-Seq}]
        {\envExpr\vdash \mathit{cls}_0\clauseor\cdots\clauseor\mathit{cls}_n:\tau}
        {\envExpr\vdash cls_0:\tau &
        \cdots &
        \envExpr\vdash cls_n:\tau}
\end{gather}
\end{subequations}

\subsection{付値}\label{sc:evaluation}
値$\upsilon$は
\begin{equation}\label{eq:eval-value} 
\begin{array}{rcll}
\upsilon&\Coloneqq& \mypair{}{c:\tau}                          & \text{定数} \\
 &\mid&  s:\tau                     & \text{外部定数} \\
 &\mid&  v                          & \text{変数} \\
 &\mid&  \mypair{g}{\upsilon}       & \text{型構築子} \\
 &\mid&  \lambdadot{x}{e}           & \text{関数} \\
 &\mid&  e, \cdots, e               & \text{組}
\end{array}
\end{equation}
と定義される．

環境
\begin{gather}\label{eq:eval-func} 
\nu\msubset\mathit{Var}\times\mathit{Var} \\
\rho\msubset\mathit{Var}\times\upsilon \\
\end{gather}

\begin{subequations}
\begin{align}
    \semanticS{c}\nu\rho &= \valueandenv{c}{\rho}\\
    \semanticS{v}\nu\rho &= \valueandenv{\nu(v)}{\rho}\\
    \semanticS{\mathnkop{if}e_1\tau_1\mathnkop{then}e_2\mathnkop{else}e_3}\nu\rho &= \begin{cases}
        \semanticS{e_2}\nu\rho' &\text{if $\semanticS{e_1}\nu\rho = \valueandenv{\mathnkval{true}}{\rho'}$} \\
        \semanticS{e_3}\nu\rho' &\text{if $\semanticS{e_1}\nu\rho = \valueandenv{\mathnkval{false}}{\rho'}$} \\
        \end{cases}
\end{align}
\end{subequations}

\end{resbonsiblesection}

\begin{resbonsiblesection}{標準ライブラリ}{\kobori}
nibkame言語で標準で使用できる関数の仕様について述べる．

ここで述べる関数はソースコードの読み込み以前から定義されており，自ら定義
した関数と同じように使用することができる．

\subsection{算術演算}
使用できる算術演算子とその型を次に示す．括弧で囲まれた識別子は中置演算子
であることを示す．それぞれの優先順位は普段の計算と同じである．
\begin{lstlisting}
 (+) : int -> int -> int
 (-) : int -> int -> int
 ( * ) : int -> int -> int
 (/) : int -> int -> int
 (+.) : float -> float -> float
 (-.) : float -> float -> float
 ( *. ) : float -> float -> float
 (/.) : float -> float -> float
\end{lstlisting}

\subsection{比較演算子}
使用できる比較演算子とその型を次に示す．それぞれの演算子は算術演算子より
優先順位は低い．
\begin{lstlisting}
 (=) : 'a -> 'a -> bool
 (<>) : 'a -> 'a -> bool
 (<=) : 'a -> 'a -> bool
 (<) : 'a -> 'a -> bool
 (>) : 'a -> 'a -> bool
 (>=) : 'a -> 'a -> bool
\end{lstlisting}
順序比較は整数と浮動小数点数，文字型のみに定義され，タプルや配列に対して
は未定義である．

\subsection{副作用を扱う関数}
引数を計算に用いないことを明示的に示すため，次の関数が定義されている．
\begin{lstlisting}
 ignore : 'a -> unit
\end{lstlisting}

\subsection{標準出力関数}
次の関数は，それぞれの引数を構文解析器へ入力可能な形式で印字する関数であ
る．
\begin{lstlisting}
 print_int : int -> unit
 print_float : float -> unit
 print_char : char -> unit
 print_string : char array -> unit
\end{lstlisting}

\subsection{リスト処理関数}
リスト型の値を処理する関数を次に示す．
\begin{lstlisting}
 hd : 'a list -> 'a
 tl : 'a list -> 'a list
 null : 'a list -> bool
 map : ('a -> 'b) -> 'a list -> 'b list
 length : 'a list -> int
\end{lstlisting}
\lstinline|hd|と\lstinline|tl|はそれぞれ，リストから先頭の要素か後続のリ
ストを取り出す関数である．空のリストを適用した場合の動作は未定義である．
\lstinline|null|はリストの末尾であるか判定する関数である．
\lstinline|map|は，第2引数のリストの各要素に第1引数の関数を適用し，結果
をリストにして返す関数である．
\lstinline|length|はリストの長さを求める関数である．

\subsection{配列処理関数}
配列を操作する関数を次に示す．配列の更新は破壊的であることに注意する必要
がある．
\begin{lstlisting}
 array-create : 'a -> int -> 'a array
 array-set : 'a array -> 'a -> int -> unit
 array-ref : 'a array -> int -> 'a
 array-from-list : 'a list -> 'a array
 array-from-list-with-length : int -> 'a list -> 'a array
\end{lstlisting}
\lstinline|array-create|は第1引数を初期値とした，長さが第2引数だけの配列
を新たに生成する関数である．
\lstinline|array-set|は配列の指定した要素を破壊的に更新する関数である．
\lstinline|array-ref|は配列の指定した要素を取り出す関数である．
\lstinline|array-from-list|はリストと同じ長さで同じ要素を持つ配列を生成
する関数である．
\lstinline|array-from-list-with-length|はリストの内，指定されただけの先
頭要素を持つ配列を生成する．リストより長い値が指定されたとき，それ以降の% 本当に？
値は未定義である．

\end{resbonsiblesection}

\chapter{コンパイラの設計と実装}\label{ch:impl}

\begin{abstract}
はじめに，nibkameコンパイラの構造とフェーズを示し，後に工程の詳細を説明
していく．
\end{abstract}

\begin{resbonsiblesection}{コンパイラのモジュール構造}{\kobori}
nibkameコンパイラのモジュール構造と，各フェーズで行う操作を次に示す．

\begin{itemize}
 \item 構文解析 (Schemeで実装)
 \item 翻訳単位を丸ごとモジュール化 (Moduleモジュール、TranslationUnitモ
       ジュール)
 \item S式表現の読み込み (Sexprモジュール、Sreadモジュール、Variantモジュー
       ル)
 \item クロージャ化 (LLiftingモジュール)
 \item 型推論 (Typingモジュール)
 \item パターンマッチの展開 (Patternモジュール)
 \item 多相関数の特殊化 (Instantiateモジュール)
 \item K正規形へ変換 (KNormalモジュール)
 \item 部分適用に関する処理 (Closureモジュール)
 \item 仮想機械語に変換 (VirtualAsmモジュール)
 \item 仮想機械語の線形化 (Basicblockモジュール)
 \item レジスタ割付 (RegAllocモジュール)
 \item 機械語を出力 (Asmx86モジュール)
\end{itemize}

各フェーズは独自の中間言語を持っており，前段階の表現を自らで定義する中間
言語に翻訳することで，所定の動作を実現している．
\end{resbonsiblesection}

\begin{resbonsiblesection}{構文解析部}{\sakamoto}\label{sc:impl-parsing}
現在のところ，構文解析部は
解析表現文法(Parsing Expression Grammar, PEG)\cite{Ford:2004:PEG:982962.964011}の
実装であるParsec\cite{Hutton96monadicparser}を
Schemeへ移植したライブラリ\footnote{Gaucheのソースコードに付属}
を用いて書かれている．
\end{resbonsiblesection}

\begin{resbonsiblesection}{型推論部}{\sakamoto}\label{sc:impl-type-inference}
現在のところ，型推論部は
\algorithmW\cite{Milner1978348}\cite{Damas:1982:PTF:582153.582176}の
CamlLightにおける実装\cite{Lee:1998:PFL:291891.291892}を参考にしつつ
それを拡張して利用した．
型の合一化のアルゴリズムは
\algorithmU\cite{DBLP:books/el/RV01/BaaderS01}
を使用している．

そのため，非常に計算量が大きくなっており，
\cite{DBLP:journals/jfp/HengleinM94}の
第3節にあるような型をもつ関数に対する型推論を
現実的な時間・メモリ使用量で終わらせることが出来ない．

ヴァリアントの扱いは\cite{DBLP:conf/ctcs/Hagino87}を参考にした．
\end{resbonsiblesection}


\chapter{サンプルプログラムと実行結果}\label{ch:sample-program}

\chapter{結論}\label{ch:conclude}

%\chapter*{謝辞}
\addcontentsline{toc}{chapter}{謝辞}
\section*{謝辞}
樋口先生にはプロジェクト計画についてご意見をいただきました．大墳先生には発表
資料の作成や発表についてご指導いただきました．牛田先生には予稿などの書法につ
いて助言をいただきました．深謝の意を表します．

\bibliographystyle{jplain}
\bibliography{reference}

\backmatter
\appendix

\end{document}
