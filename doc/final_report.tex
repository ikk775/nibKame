\documentclass[a4paper,titlepage,report]{jsbook}

\usepackage[dvipdfmx]{graphicx}
\usepackage{emp} % 図の描画用
\usepackage[sc,slantedGreek]{mathpazo}
\usepackage{listings}
\usepackage{jlisting}
\usepackage{mathtools} % Ams-TeXの使用
\usepackage{mathrsfs} % 数式フォント
\usepackage{amssymb,amsthm} % 記号と定理環境
\usepackage{proof} % 証明図
\usepackage{url} % URL
\usepackage{longtable} % 複数ページに亙る長い表
\usepackage{yhmath} % 長い括弧など

\input{preamble}

\begin{document}
\title{電子情報工学科実験報告書 \\ 関数型言語の設計と実装}
\author{
\begin{tabular}{llr}
 L班 & 07317 & 小堀 育男 \\
     & 07322 & 酒本 典明
\end{tabular}
}
\date{平成23年2月3日}

\frontmatter

\maketitle

\tableofcontents
\listoffigures
\listoftables
\lstlistoflistings

\newpage

\section{序論}\label{sc:intro}
関数型言語と呼ばれるプログラム言語に由来する機能が，C++やJava, C\# など
の言語に取り込まれている．またScala\footnote{\url{http://www.scala-lang.org/}}
やF\#{}\footnote{\url{http://msdn.microsoft.com/ja-jp/fsharp}}
など既存の手続き型言語との連携を強く意識した言語も登場している．

関数型言語に特徴的な機能として第一級の関数やクロージャなどがある．これら
は計算機の命令セットの持つ機能からかけ離れている．こういった機能を持った
言語を設計し，実装することで機能に対する理解を深めることを目標とする．

そのために，我々は静的に強く型付けされる関数型言語nibkameを設計しコンパ
イラを実装した．これは学生実験における参照実装として開発された
MinCaml\cite{住井英二郎:2008-04-24}を基にして開発を行なった．

MinCamlおよびMinCamlコンパイラは簡潔な実装(約2000行ほど)で性能の良いコー
ドを生成することに特徴のある関数型言語である．構文はObjective
Caml\footnote{\url{http://caml.inria.fr/ocaml/}}のサブセットであり,算術演算や
タプル構造，破壊的代入の可能な配列，高階関数，再帰と末尾呼び出し，型推論
などの機能が実現されており，レイトレーシングなどの複雑なプログラムを記述
することができる．MinCamlはプログラム言語処理系の教材として用いられるこ
とを主眼としており，その機能選定は実装を簡潔に保つことを重視して行われた．

簡潔さを保つために，多くのアプリケーションプログラムを記述するときに必須
でない機能は省略された．その中にはMinCamlコンパイラの記述に多く用いられ
ている代数的データ型やパターンマッチングなどが存在する．
nibkameではそういった機能と，その他にも生産性に高い影響を与える機能を追
加することでより実用的な言語を開発することを目指した．
MinCamlコンパイラはターゲットとする計算機としてSPARCとPowerPCをサポート
している．しかし実行する計算機の確保の容易さから，nibkameコンパイラはター
ゲットをx86プロセッサとした．

\subsection{実装規模}
コンパイラの主要部分はObjective
Camlを用いて実装した．構文解析部分はScheme
(処理系としては
Gauche\footnote{\url{http://practical-scheme.net/gauche/index-j.html}})
を用いた．実行時ランタイムはC言語にて実装した．
% ここに行数などを含むといいみたい

2011年1月12日時点でのソースコードの全行数は7001行であり，
ソースソードの目的別言語別行数内訳は以下のようになっている．
\begin{itemize}
 \item 本体
       \begin{description}
	\item[O'Caml 実装] 4820行
	\item[O'Caml インターフェース] 781行
	\item[Scheme] 337行
	\item[C言語] 0行
       \end{description}
 \item 単体テスト
       \begin{description}
	\item[O'Caml 実装部分] 1063行
       \end{description}
\end{itemize}

\subsection{報告書の構成} % ここは内容にあわせて書き換えてください．あと
			  % subsectionはオーバースペックな気が．
\refCh{ch:lang_design}では，まずnibkame言語に搭載された機能のうち関数型
言語に特有なものについて説明し，次に最終的に実装された言語機能と構文を示
す．
\refSc{sc:impl}ではコンパイラの持つ中間言語と実行する翻訳に主眼を置いて
コンパイラの実装について説明する．
\refSc{sc:sample}では実際のnibkameプログラムの例を示し，コンパイラの動作
と得られる目的プログラムについて説明する．
\refSc{sc:conclu}では実装した機能についてまとめ，これからの課題を議論する．

%かくこと
%\begin{itemize}
% \item なぜ関数型 (MinCamlをなぜ参考したか)
% \item 既存のものとの比較 (機能なりターゲットコードなり対象なり)
%\end{itemize}
\mainmatter
%\chapter{原理}\label{ch:原理}

\chapter{準備}\label{ch:preparation}
\begin{abstract}
本報告書で用いる理論・記法について概説する． 
本章は直感的な解りやすさを最優先したため，
論理的に不正確な箇所が多々あるがお赦し願いたい．
\end{abstract}

\section{全体的な記法について}\label{sec:about-notation}
以下，演算子の結合力を表す際に，
\begin{equation}\label{eq:bonding-strength}
\times \gtrdotrel +
\end{equation}
と表すこととする．
これは，$A\times B + C$という式があったときに$(A\times B)+ C$と解釈することを意味する．

等号の使い分けは以下のようにする．

\section{集合について}\label{sec:about-set}
元として含むことを表す記号として$\in$，$\ni$を用いる.

部分集合を表す記号として$\msubset$，$\msupset$を，
真部分集合を表す記号として$\mpsubset$，$\mpsupset$を用いる． 

空集合の記号としては$\emptyset$を用いる.

\section{論理について}\label{sec:about-logic}
真・偽を表すの記号として夫々，$\ltrue$，$\lfalse$を用いる.
論理和・論理積・否定・含意の記号として夫々，$\lor$，$\land$，$\lnot$，$\limpl$を用いる.
$\limpl$は右結合性，即ち$A\limpl B\limpl C \equiv A\limpl (B\limpl C)$とする．
夫々の演算子の優先順位は$\lnot\gtrdotrel\land,\lor\gtrdotrel\limpl$とする．

\begin{equation}\label{eq:def-mp}
\infer[\text{M.P.}]{Q}{P & P \limpl Q}
\end{equation}
は，$P$と$P \limpl Q$という仮定から，M.P.という推論規則によって$Q$が導き出されることを表す記法である.
\ref{eq:def-mp}によって定義される推論規則は，推論規則内の$P$，$Q$に式を代入することによって
\begin{equation}\label{eq:def-mp-instance-1}
\infer[\text{M.P.}]{A\land B}{A & A \limpl A\land B}
\end{equation}
や，
\begin{equation}\label{eq:def-mp-instance-2}
\infer[\text{M.P.}]{\foralldot{x}{P_2(a, x) \limpl P_1(x)}}{\existsdot{x}{P_1(x)} & \existsdot{x}{P_1(x)} \limpl \foralldot{x}{P_2(a, x) \limpl P_1(x)}}
\end{equation}
も表す．このように，文脈上の


$\Gamma_1,\Gamma_2,\cdots\vdash A_1, A_2,\cdots$は，
主に，$\Gamma_1, \Gamma_2, \cdots$から$A_1, A_2, \cdots$が推論できることを表す記法として用いる.

\section{ラムダ記法について}\label{sec:about-lambda-notation}
ラムダ記法(lambda notation) とは，一言で言ってしまうと関数を抽象化したものである．

例えば以下の式を考えよう．
\begin{align}
f(x) &= (x + 1)^2\\
f(x + 1) &= x^2 + 4x + 4\\
(x + 1) &= x + 1
\end{align}
これは$(x + 1)$に対して関数$f$を適用すると$x^2 + 2x + 1$となるが，
関数を適用しないとそれは$x + 1$そのものであることを表している．

では逆に，$f$に引数を適用しないとどうなるのであろうか．
\begin{align}
f(x) &= x^2 + 2x + 1\\
f    &= \;?
\end{align}
この場合の$f$そのものを表すのにラムダ記法を用いることが出来，そうすると
\begin{align}
f &= \lambdadot{x}{(x^2 + 2x + 1)} \\
\end{align}
となって関数そのものを陽に扱うことが出来る．
以下，必要の無い限り括弧は省略し，$\lambdadot{x}{(x^2 + 2x + 1)}$は$\lambdadot{x}{x^2 + 2x + 1}$と書く．

ラムダ記法を用いて記述した関数に引数を適用させると，
\begin{align}
f(y) &= (\lambdadot{x}{x^2 + 2x + 1})(y) = y^2 + 2y + 2 \\
f(2) &= (\lambdadot{x}{x^2 + 2x + 1})(2) = 2^2 + 2\cdot 2 + 1 = 9
\end{align}
となる．

次に複数引数の関数を考えよう．
\begin{align}
g(x, y) &= x + y
\end{align}
この関数を表すためには，
$\lambdadot{x,y}{}$という記法を導入するのが良いと思われる．
従って，
\begin{align}
\label{eq:lambda-multiple}
g &= \lambdadot{x,y}{x + y}\\
\label{eq:lambda-multiple-inst}
g(a, b) &= a + b\\
g(1, 2) &= (\lambdadot{x,y}{x + y})(1, 2) = 1 + 2 = 3
\end{align}
と表せる．

ここで，天下り的ではあるが，$\lambdadot{x}{\lambdadot{y}{x+y}}$を考える．
すると，
\begin{gather}
\begin{aligned}
\label{eq:lambda-curried}
h &= \lambdadot{x}{\lambdadot{y}{x+y}} \\
\end{aligned}\\
\begin{aligned}
h(a) &= (\lambdadot{x}{\lambdadot{y}{x+y}})(a) \nonumber \\
     &= {\lambdadot{y}{a+y}}
\end{aligned}\\
\begin{aligned}
\label{eq:lambda-curried-inst}
h(a)(b) &= (\lambdadot{x}{\lambdadot{y}{x+y}})(a)(b) \nonumber\\
        &= {\lambdadot{y}{a+y}}(b) \nonumber\\
        &= a + b
\end{aligned}\\
\begin{aligned}
h(1)(2) &= (\lambdadot{x}{\lambdadot{y}{x+y}})(1)(2) \nonumber \\
        &= {\lambdadot{y}{1+y}}(2) \nonumber \\
        &= 1 + 2 = 3
\end{aligned}
\end{gather}
このようになる．

ここで，
\refEq{eq:lambda-multiple-inst}と\refEq{eq:lambda-curried-inst}
を見比べると$g(a, b) = h(a)(b)$であることがわかる．
つまり，
\begin{equation}
(\lambdadot{x,y}{\cdots})(a,b) \equiv (\lambdadot{x}{\lambdadot{y}{\cdots}})(a)(b)
\end{equation}
といえる．

これは簡単に拡張が出来て，任意の多変数関数$g$に対してある関数$h$があって
\begin{equation}
g(a_1, a_2, \cdots, a_n)= h(a_1)(a_2)\cdots(a_n)
\end{equation}
となる．
この操作$\mathrm{curry}: g\mapsto h$をカリー化(currying)と呼ぶ．

従って，カリー化を行うことにより全ての多変数関数は一変数関数で書くことが出来る．

\section{ラムダ計算}\label{sc:about-lambda-calculus}
\section{型付ラムダ計算}\label{sc:about-typed-lambda-calculus}
\section{型理論}\label{sc:about-type-theory}

\chapter{対象言語の設計}\label{ch:lang_design}

\begin{abstract}
この章では，言語の仕様とその背景，設計思想について述べる．
そして，最終的に実装された言語機能と構文を示す．
\end{abstract}

\section{型システム}\label{sec:型システム}
nibkameでは型システムとして，Hindley-Milner型システムを採用した．

Hindley-Milner型システムとはHaskellやMLのような静的型付け関数プログラミング言語によく用いられる型システムであり，
「すべての式に一意な最汎(most general)型，即ち主型(principal type)を付けることができる」という重要な性質を持つ．

代表的なアルゴリズムは「\algorithmW」\cite{Milner1978348}\cite{Damas:1982:PTF:582153.582176}として知られているものである．
このアルゴリズムはHindley-MilnerアルゴリズムともDamas-Milnerアルゴリズムとも呼ばれる．
型変数への代入による型の同一化(unification)を基本操作としている．

このアルゴリズムの起源は，Haskell CurryとRobert Feysが1958年に単純型付ラムダ計算の型推論のために考案したものであり，
1969年にJ. Roger Hindleyがそれを拡張し，また，それが常に最汎な型に推論することを証明した．
1978年にRobin MilnerはHindleyとは独立に\algorithmW\cite{Milner1978348}を導き出し，
1982年，Luis Damasが最終的にMilnerのアルゴリズムの完全性を証明した\cite{Damas:1982:PTF:582153.582176}．

Hindley-Milner型システムを採用したnibkameでは型は以下の様に定義される．
\begin{equation}\label{eq:type} 
\begin{array}{rcll}
    \tau    &\Coloneqq& \iota                       & \text{型定数} \\
            &\mid&  \alpha                          & \text{型変数} \\
            &\mid&  \tau \rightarrow \tau           & \text{関数型} \\
            &\mid&  \tau \times \cdots \times \tau  & \text{直積型} \\
            &\mid&  \tau \tau                       & \text{多相のヴァリアント} \\
    \sigma  &\Coloneqq & \tau                       & \text{量化なし} \\
            &\mid&  \foralldot{\alpha}{\sigma}      & \text{全称量化}
\end{array}
\end{equation}
直和形については型推論部では扱わない．

\subsection{実例}\label{ssc:example}

\subsection{型定数}\label{ssc:type-constant}

\section{内部の設計と実装}\label{sc:impl}

\section{サンプルプログラムと実行結果}\label{sc:sample}

\section{結論}\label{sc:conclu}

\section*{謝辞}
樋口先生にはプロジェクト計画についてご意見をいただきました．大墳先生には発表
資料の作成や発表についてご指導いただきました．牛田先生には予稿などの書法につ
いて助言をいただきました．深謝の意を表します．

\bibliographystyle{jplain}
\bibliography{reference}

\backmatter
\appendix

\end{document}
