
space	::= (' ' | '\t'| '\n' | '\r')*;
digit	::= [0-9];
lower	::= [a-z];
upper	::= [A-Z];

s ::= space;

lparen 	::= '(';
rparen 	::= ')';

minus 	::= minus: '-';
plus	::= plus: '+';
minus_d	::= minus_d: "-.";
plus_d	::= plus_d: "+.";
ast	::= ast: '*';
slash	::= slash: '/';
ast_d	::= ast_d: "*.";
slash_d	::= slash_d: "/.";

equal	::= eq: '=';
less_greater  ::= neq: "<>";
less_equal    ::= le: "<=";
less	      ::= lt: '<';
greater_equal ::= ge: ">=";
greater       ::= gt: '>';

Comparator ::= less_greater | less_equal | less | equal | greater_equal | greater;

integer	::= <Integer>{ ('-' | '+')? digit (digit | '_')* }</Integer>;
real ::= <Real>{ ('-' | '+')? digit+ dot digit* (('e' | 'E') ('-' | '+')? digit+)? }</Real>;


true	::= ture: "true";
false	::= false: "false";
bool	::= <Boolean> true | false </Boolean>;

if	::= "if";
then	::= "then";
else	::= "else";
let	::= "let";
in	::= has_body: "in";
rec	::= rec: "rec";

reserved ::= if | then | else | let | in | rec | bool;

any 	::= '_';
assign	::= "<-";
semicolon ::= ';';
conma	  ::= ',';
dot	  ::= '.';

ident	  ::= <Ident>{ ~reserved (lower | upper | '_' ) (digit | lower | upper | '_')* }</Ident>;

simple_expr ::=
      lparen s expr s rparen
    | lparen s rparen
    | bool
    | real
    | integer
    | ident
    ;

expr ::= <Expr>
      let_expr
    | if_expr
    | apply_expr
    | add_expr
    | mul_expr
    | comp_expr
    | tuple_expr
    | simple_expr
    </Expr>;

add_expr ::=
      <Add> term (s pm_opr s term)+ </Add>;

pm_opr ::= plus_d | minus_d | plus | minus;

term ::=
      mul_expr | simple_expr;

mul_expr ::=
      <Mul> simple_expr (s as_opr s simple_expr)+ </Mul>;

as_opr ::= (ast_d | slash_d | ast | slash);

comp_expr ::=
      <Comp> (add_expr | simple_expr) (s Comparator s (add_expr | simple_expr))+ </Comp>;

if_expr ::=
    	<If> if s expr s then s expr s (else s expr)? </If>;

let_expr ::=
      <VarDecl> let s ident s equal s expr s in expr </VarDecl>
    | <FunDecl> let s rec? s ident s formal_args s equal s expr (s in s expr)? </FunDecl>;

apply_expr ::=
      <Apply> ident s actual_args </Apply>;

formal_args ::=
      <Formal_args> ident (s ident)* </Formal_args>;

actual_args ::=
      <Actual_args> simple_expr (s simple_expr)+ </Actual_args>;

tuple_expr ::=
      simple_expr (s conma s simple_expr)+;

start ::= <ExprList> (expr s)* </ExprList> EOF;

