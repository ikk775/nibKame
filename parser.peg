
space	::= (' ' | '\t'| '\n' | '\r')*;
digit	::= [0-9];
lower	::= [a-z];
upper	::= [A-Z];

s ::= space;

lparen 	::= '(';
rparen 	::= ')';

minus 	::= '-';
plus	::= '+';
minus_d	::= "-.";
plus_d	::= "+.";
ast	::= '*';
slash	::= '/';
ast_d	::= "*.";
slash_d	::= "/.";

equal	::= '=';
less_greater  ::= "<>";
less_equal    ::= "<=";
less	      ::= '<';
greater_equal ::= ">=";
greater       ::= '>';

Comparator ::= less_greater | less_equal | less | equal | greater_equal | greater;

integer	::= <Integer>{ ('-' | '+')? digit (digit | '_')* }</Integer>;
real ::= <Real>{ ('-' | '+')? digit+ dot digit* (('e' | 'E') ('-' | '+')? digit+)? }</Real>;


true	::= "true";
false	::= "false";
bool	::= <Boolean> true | false </Boolean>;

if	::= "if";
then	::= "then";
else	::= "else";
let	::= "let";
in	::= "in";
rec	::= <Rec> "rec" </Rec>;

reserved ::= if | then | else | let | in | rec | bool;

any 	::= '_';
assign	::= "<-";
semicolon ::= ';';
conma	  ::= ',';
dot	  ::= '.';

ident	  ::= <Ident>{ ~reserved (lower | upper | '_' ) (digit | lower | upper | '_')* }</Ident>;

simple_expr ::=
      lparen s expr s rparen
    | lparen s rparen
    | bool
    | real
    | integer
    | ident
    ;

expr ::= <Expr>
      let_expr
    | if_expr
    | apply_expr
    | add_expr
    | mul_expr
    | comp_expr
    | tuple_expr
    | simple_expr
    </Expr>;

add_expr ::=
      <Add> term (s pm_opr s term)+ </Add>;

pm_opr ::= <PM>{ plus_d | minus_d | plus | minus }</PM>;

term ::=
      mul_expr | simple_expr;

mul_expr ::=
      <Mul> simple_expr (s as_opr s simple_expr)+ </Mul>;

as_opr ::= <AS>{ (ast_d | slash_d | ast | slash) }</AS>;

comp_expr ::=
      <Comp> (add_expr | simple_expr) (s Comparator s (add_expr | simple_expr))+ </Comp>;

if_expr ::=
    	<If> if s expr s then s expr s (else s expr)? </If>;

let_expr ::=
      <VarDecl> let s ident s equal s expr s in expr </VarDecl>
    | <FunDecl> let s rec? s ident s formal_args s equal s expr (s in s <Body> expr </Body> )? </FunDecl>;

apply_expr ::=
      <Apply> ident s actual_args </Apply>;

formal_args ::=
      <Formal_args> ident (s ident)* </Formal_args>;

actual_args ::=
      <Actual_args> simple_expr (s simple_expr)+ </Actual_args>;

tuple_expr ::=
      simple_expr (s conma s simple_expr)+;

start ::= <ExprList> (expr s)* </ExprList> EOF;

