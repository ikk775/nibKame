
space	::= (' ' / '\t'/ '\n' / '\r')*;
digit	::= ['0'-'9'];
lower	::= ['a'-'z'];
upper	::= ['A'-'Z'];

s ::= space;

lparen 	::= '(';
rparen 	::= ')';

minus 	::= '-';
plus	::= '+';
minus_d	::= "-.";
plus_d	::= "+.";
ast	::= '*';
slash	::= '/';
ast_d	::= "*.";
slash_d	::= "/.";
equal	::= '=';
less_greater  ::= "<>";
less_equal    ::= "<=";
less	      ::= '<';
greater_equal ::= ">=";

integer	::= digit+;
(* real	::= digit+ ('.' digit* / ['e' 'E'] ['+' '-']? digit+); *)
real    ::= digit+ ('.' digit* / ('.' digit*)? ['e' 'E'] ['+' '-']? digit+);
(* number ::= real / integer; *) 

true	::= "true";
false	::= "false";
bool	::= true / false;

if	::= "if";
then	::= "then";
else	::= "else";
let	::= "let";
in	::= "in";
rec	::= "rec";

any 	::= '_';
assign	::= "<-";
semicolon ::= ";";
conma	  ::= ',';
dot	  ::= '.';

ident	  ::= (digit / lower / upper / '_')+;

simple_expr ::=
    / lparen s expr s rparen
    / lparen s rperen
    / bool
    / float
    / integer
    / ident
    ;

expr	::=
    / simple_expr
    / let_expr
    / if_expr
    / add_expr
    / mul_expr
    ;

add_expr ::=
      value s (plus_d / minus_d / plus / minus) s add_expr;

mul_expr ::=
      expr s (ast_d / slash_d / ast / slash) s mul_expr;

value ::=
      mul_expr / expr;

if_expr ::=
    	if s expr s then s expr s (else s expr)?;

let_expr ::=
      let s ident s equal s expr s in expr
    / let rec? formal_args equal expr in expr;

formal_args ::=
      ident s formal_args;

actual_args ::=
      simple_expr s autual_args;

tuple_expr ::=
      simple_expr (s conma s simple_expr)+;

